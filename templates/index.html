<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vexara AI Assistant</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link
      rel="icon"
      href="/static/images/vexara-new1-removebg-preview.png"
      type="image/png"
    />
    <!-- In your HTML head -->
    <link
      href="https://fonts.googleapis.com/css2?family=Cascadia+Code&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />

    <link
      rel="stylesheet"
      href="https://cdn-uicons.flaticon.com/uicons-regular-rounded/css/uicons-regular-rounded.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn-uicons.flaticon.com/3.0.0/uicons-regular-rounded/css/uicons-regular-rounded.css"
    />
    <!-- <link rel="stylesheet" href="/static/style.css"> -->
    <style>
      :root {
    --primary-color: #8a8a8b; /* ChatGPT green */
    --primary-light: #18cd9f;
    --accent-color: #6a0dad; /* A subtle purple/blue for some accents */
    --bg-color: #ffffff; /* Light gray for body background */
    --text-color: #303030; /* Darker text */
    --text-light: #606060;
    --sidebar-bg: #f9f9f9; /* Dark background for sidebar */
    --sidebar-text: #413229;
    --chat-bg: #fffefe; /* White chat background */
    --user-message-bg: #f5f4f5; /* Lighter blue for user messages, or a very light gray if preferred */
    --bot-message-bg: transparent;
    /* Very light gray for bot messages */
    --code-bg: #2d2d2d; /* Dark code blocks */
    --code-text-color: #f8f8f2; /* Light text for code */
    --border-radius: 10px; /* Slightly more rounded corners for main elements */
    --border-radius-sm: 6px; /* Smaller radius for buttons/inputs */
    --shadow: 0 1px 3px rgba(0, 0, 0, 0.1); /* Softer shadows */
    --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
    --web-search: rgba(0, 0, 0, 0.2);
    --transition: all 0.2s ease-in-out; /* Smooth transitions */
    --model-text-color: white;
  }

  /* Dark Mode Variables */
  .dark-mode {
    --model-text-color: white;
    --primary-color: #929292;
    --primary-light: #52a167;
    --accent-color: #6a0dad; /* A deeper, more subtle purple */
    --bg-color: #212121; /* Very dark background with a hint of gray */
    --text-color: #f0f0f0; /* Soft, readable gray for primary text */
    --text-light: #7c7c7c; /* Subtle gray for secondary text */
    --sidebar-bg: #1a1a1a; /* Distinct from main background */
    --sidebar-text: #e0e0e0;
    --chat-bg: #212121;
    --user-message-bg: #333537; /* A softer shade for user messages */
    --bot-message-bg: transparent;
    --code-bg: #1e1e1e;
    --code-text-color: #f0f0f0;
    --shadow: 0 2px 4px rgba(0, 0, 0, 0.5); /* Stronger shadow for depth */
    --shadow-md: 0 6px 10px rgba(0, 0, 0, 0.6);
    --web-search: rgba(255, 255, 255, 0.439);
  }

  /* Base Styles */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text",
      "SF Pro Display", sans-serif;
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: var(--transition);
    display: flex;
    min-height: 100vh; /* Ensures body takes full viewport height */
    overflow: hidden; /* Prevents body scroll when sidebar is fixed */
  }

  /* Sidebar Styles */
  .sidebar {
    width: 260px; /* Slightly narrower like ChatGPT */
    background: var(--sidebar-bg);
    color: var(--sidebar-text);
    padding: 16px; /* Reduced padding slightly */
    display: flex;
    flex-direction: column;
    height: 100vh;
    flex-shrink: 0;
    transition: width 0.3s ease, padding 0.3s ease, transform 0.3s ease;
    overflow-x: hidden;
    position: relative;
    z-index: 100;
    border-right: 1px solid rgba(48, 48, 48, 0.099); /* Subtle border */
  }
  .dark-mode .sidebar {
    border-right: 1px solid rgba(255, 255, 255, 0.05);
  }

  .sidebar.collapsed {
    width: 70px; /* Collapsed width */
    padding: 16px 10px; /* Adjust padding for collapsed state */
    min-width: 70px; /* Ensures it collapses to this width */
    background-color: #ffffff;
    border-right: 1px solid rgba(48, 48, 48, 0.099);
  }
  .dark-mode .sidebar.sidebar.collapsed {
    background-color: #212121;
    border-right: 1px solid #2c2c2c;
  }

  /* Main Content Styles */
  .main {
    flex: 1; /* Takes remaining space */
    display: flex;
    flex-direction: column;
    height: 100vh; /* Ensure main also takes full viewport height */
    margin-left: 260px; /* Default margin for desktop, equals sidebar width */
    transition: margin-left 0.5s ease;
    position: relative; /* For z-index context */
  }

  .main.full-width {
    /* Applied when sidebar is collapsed on desktop */
    margin-left: 150px; /* Adjusted margin when sidebar is collapsed */
  }

  .main.full-screen {
    /* For true full screen chat (sidebar hidden) */
    margin-left: 0;
    width: 100%;
  }

  /* Floating sidebar toggle button */
  #showSidebarBtn {
    display: none;
    position: fixed;
    top: -10px;
    left: 15px;
    z-index: 100;
    background: transparent; /* Use transparent */
    color: black; /* Match sidebar text color */
    border: none;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 1.2rem;
    cursor: ew-resize;
    box-shadow: none; /* Remove shadow for a clean flat look */
    transition: var(--transition);
    align-items: center;
    justify-content: center;
    margin-top: 120px;
  }
  .dark-mode #showSidebarBtn {
    color: white;
  }
  .dark-mode .sidebar-show-btn {
    color: white;
  }

  /* Optional hover effect */
  .dark-mode #showSidebarBtn:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.05);
  }
  #showSidebarBtn:hover {
    background: #dee2ec;
    transform: scale(1.05);
  }

  /* Sidebar Toggle button inside the sidebar header */
  .sidebar-toggle {
    background: none;
    border: none;
    color: var(--sidebar-text);
    font-size: 1.1rem; /* Slightly smaller for internal toggle */
    cursor: ew-resize;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 45px;
    height: 45px;
    border-radius: 50%;
    transition: var(--transition);
  }

  .sidebar-toggle:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .sidebar.collapsed .sidebar-toggle {
    transform: rotate(180deg); /* Rotate for collapsed state */
  }
  .dark-mode .sidebar.collapsed .sidebar-toggle:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  /* Responsive Adjustments */
  @media (min-width: 769px) {
    .main {
      margin-left: 260px; /* Default margin for desktop */
    }
    .sidebar.collapsed + .main {
      /* When sidebar is collapsed, main takes full width */
      margin-left: 70px; /* Adjusted margin when sidebar is collapsed */
    }
    /* #showSidebarBtn is now used on desktop too when sidebar is fully hidden */
  }

  @media (max-width: 768px) {
    /* On mobile, sidebar is fixed and slides out */
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      height: 100%;
      transform: translateX(-100%); /* Hidden off-screen */
      width: 260px; /* Fixed width when visible */
      z-index: 100; /* Ensure it's above main content */
      box-shadow: var(--shadow-md);
    }
    .sidebar.visible {
      /* Class to show sidebar on mobile */
      transform: translateX(0);
    }
    .main {
      margin-left: 0; /* Main content always full width on mobile */
      width: 100%;
    }
    #showSidebarBtn {
      display: flex !important;
      position: fixed;
      top: -110px; /* Show floating button on mobile */
      left: 1%;
    }
    .sidebar-toggle {
      display: none;
      visibility: hidden;
    }

    /* Hide most sidebar content when collapsed on desktop, or when mobile */
    .sidebar.collapsed .sidebar-header span,
    .sidebar.collapsed .new-chat-btn span,
    .sidebar.collapsed #chat-history-list,
    .sidebar.collapsed .sidebar-footer > *:not(.sidebar-toggle) {
      /* Exclude toggle for specific hide */
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.1s ease;
    }
    /* Show content when not collapsed on desktop, or when mobile and visible */
    .sidebar:not(.collapsed) .sidebar-header span,
    .sidebar:not(.collapsed) .new-chat-btn span,
    .sidebar:not(.collapsed) #chat-history-list,
    .sidebar:not(.collapsed) .sidebar-footer > *:not(.sidebar-toggle) {
      opacity: 1;
      pointer-events: all;
    }
  }
  sidebar.collapsed #chat-history-list {
    display: none;
  }

  /* Sidebar Content */
  .sidebar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    /* border-bottom: 1px solid rgba(48, 48, 48, 0.099); */
  }

  /* Logo Styling */
  .sidebar-logo {
    font-size: 1.4rem;
    font-weight: 700;
    color: #413229;
    display: flex;
    align-items: center;
    gap: 10px;
    white-space: nowrap;
    transition: all 0.3s ease;
  }
  .dark-mode .sidebar-logo {
    color: white;
  }
  .sidebar-logo span {
    position: relative;
    left: 50%;
    font-weight: bolder;
  }

  /* ✅ Hide image by default (sidebar open) */
  .sidebar-logo img {
    display: none;
  }

  /* ✅ Show only when sidebar is collapsed */
  .sidebar.collapsed .sidebar-logo img {
    display: inline-block;
    height: 60px;
    width: 60px;
    /* background-size: cover; */
    background-repeat: no-repeat;
    padding: 8px;
    /* border-radius: 24px;  */
    transition: all 0.3s ease;
  }

  /* Hover effect for a modern feel */
  .sidebar.collapsed .sidebar-logo img:hover {
    cursor: pointer;
    transform: rotate(360deg); /* Slight zoom on hover */
  }

  /* Hide text only in collapsed mode */
  .sidebar.collapsed .sidebar-logo span {
    display: none;
  }
  .new-chat-btn {
    background: #fefeff; /* No background color */
    color: #413229;
    border: none;
    padding: 12px;
    border-radius: 24px;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    cursor: pointer;
    transition: var(--transition);
    font-weight: 500;
    box-shadow: none; /* Optional: remove shadow if you want clean transparency */
  }
  .dark-mode .new-chat-btn {
    color: white;
    background: #212327;
  }
  .dark-mode .new-chat-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .new-chat-btn:hover {
    background: #dee2ec; /* Or transparent if you don’t want any hover bg */
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
  }

  .sidebar.collapsed .new-chat-btn {
    padding: 25px;
    margin-top: 40px;
    justify-content: center;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    z-index: 10;
    background: none;

    /* padding-bottom: 10px; */
  }
  .sidebar.collapsed .new-chat-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .sidebar.collapsed .new-chat-btn span {
    display: none;
  }

  #chat-history-list {
    flex: 1;
    overflow-y: auto;
    margin-bottom: 20px;
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) rgba(255, 255, 255, 0.1);
  }

  #chat-history-list::-webkit-scrollbar {
    width: 6px;
  }

  #chat-history-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
  }

  #chat-history-list::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 10px;
  }

  .chat-link {
    padding: 10px 12px;
    border-radius: 24px;
    margin-bottom: 6px;
    cursor: pointer;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    transition: var(--transition);
    color: var(--sidebar-text);
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.95rem;
    position: relative; /* For positioning action buttons */
  }

  .chat-link:hover {
    background: rgba(255, 255, 255, 1);
  }
  .dark-mode .chat-link:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .chat-link.active {
    background: rgba(
      255,
      255,
      255,
      1
    ); /* More subtle active state for history */
    font-weight: 500;
  }
  .dark-mode .chat-link.active {
    background: rgba(255, 255, 255, 0.1);
  }

  .sidebar.collapsed .chat-link {
    width: 50px; /* Square for icons */
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0;
    font-size: 1.1rem;
    border-radius: 50%; /* Make them circular when collapsed */
    display: none;
  }

  .sidebar.collapsed .chat-link span {
    display: none;
  }

  /* Chat Link Actions (Rename/Delete) */
  .chat-link-actions {
    display: flex;
    gap: 5px;
    margin-left: auto; /* Push to the right */
    opacity: 0;
    transition: opacity 0.2s ease-in-out;
    pointer-events: none; /* Initially non-interactive */
  }

  .chat-link:hover .chat-link-actions,
  .chat-link.active .chat-link-actions {
    /* Show actions on hover or when active */
    opacity: 1;
    pointer-events: all;
  }

  .chat-link-actions button {
    background: none;
    border: none;
    color: var(--sidebar-text);
    font-size: 0.85rem;
    cursor: pointer;
    padding: 5px;
    border-radius: 4px;
    transition: background 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .chat-link-actions button:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .chat-link-actions button.delete-chat-btn {
    color: #ff6b6b; /* Red for delete */
  }
  .chat-link-actions button.delete-chat-btn:hover {
    background: rgba(255, 107, 107, 0.3);
  }

  .sidebar.collapsed .chat-link-actions {
    display: none; /* Hide actions when sidebar is collapsed */
  }

  .sidebar-footer {
    padding-top: 15px;
    border-top: 1px solid rgba(48, 48, 48, 0.099);
  }
  .dark-mode .sidebar-footer {
    padding-top: 15px;
    border-top: 1px solid rgba(48, 48, 48, 1);
  }
  /* .dark-mode .sidebar-footer{
        border-top: 12px solid rgba(255, 255, 255, 0.896);
    } */

  .sidebar-btn {
    display: flex;
    align-items: center;
    width: 100%;
    padding: 10px 12px;
    text-align: left;
    background: none;
    border: none;
    color: var(--sidebar-text);
    border-radius: 24px;
    margin-bottom: 6px;
    cursor: pointer;
    transition: var(--transition);
    text-decoration: none;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    font-size: 0.95rem;
  }

  .dark-mode .sidebar-btn:hover {
    background: #212327;
  }
  .sidebar-btn:hover {
    background: #dee2ec;
  }

  .sidebar-btn i {
    margin-right: 5px;
    width: 20px; /* Fixed width for icons */
    text-align: center;
    font-size: 1rem;
    /* top: -2rem; */
  }

  .sidebar.collapsed .sidebar-btn {
    justify-content: center;
    padding: 12px 0;
    width: 50px;
    height: 50px;
    border-radius: 50%;
  }

  .dark-mode .sidebar.collapsed .sidebar-btn:hover {
    background: #212327;
  }

  .sidebar.collapsed .sidebar-btn i {
    margin-right: 0;
    font-size: 1rem;
  }

  .sidebar.collapsed .sidebar-btn span {
    /* NEW: Hide text for sidebar buttons when collapsed */
    display: none;
  }

  .user-info {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: var(--border-radius-sm);
    margin-bottom: 15px;
    font-size: 0.9rem;
    color: var(--sidebar-text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .user-info i {
    font-size: 1.2rem;
    color: var(--accent-color); /* Use accent color for user icon */
  }

  .user-email {
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .sidebar.collapsed .user-info {
    justify-content: center;
    padding: 10px 0;
    width: 50px;
    height: 50px;
    margin: 0 auto 15px auto;
    border-radius: 50%;
  }

  .sidebar.collapsed .user-info i {
    font-size: 1.4rem;
    margin-right: 0;
  }

  .sidebar.collapsed .user-info .user-email {
    display: none;
  }

  /* Top Bar Styles (Main content header) */
  .top-bar {
    padding: 12px 20px;
    background-color: #fffefe;
    display: flex;
    width: 100%;
    justify-content: flex-end;
    align-items: center;
    z-index: 10;
    height: 3rem;
    /* visibility: hidden; */
    border-bottom: 1.5px solid #efefef;
    border-bottom-color: #f4f5f4;
    font-family: "Satoshi";
  }
  .dark-mode .top-bar {
    border: none;
    background-color: #212121;
  }

  @media (max-width: 768px) {
    .top-bar{
      /* visibility: visible; */
      border: none;
    }
    .top-bar h2{
      position: fixed;
      left: 40%;
    }
  }

  .top-bar-title {
    font-weight: 600;
    font-size: 1.1rem;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
    color: var(--text-color);
  }

  .top-bar-title i {
    color: black; /* Accent color for the logo in top bar */
    /* text-shadow: 0 0 5px rgba(24, 205, 159, 0.3); */
    height: 45px;
    width: 45px;
    right: 30px;
    top: 1px;
    position: fixed;
  }
  .top-bar-title i:hover {
    background: white;
  }
  .dark-mode .top-bar-title i {
    color: white;
    background-color: #212121;
  }

  .top-bar-actions {
    display: flex;
    gap: 8px;
  }

  .action-btn {
    background: none;
    border: none;
    color: var(--text-color);
    font-size: 1.1rem;

    padding: 6px;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: var(--transition);
  }

  /* .action-btn:hover {
        background: rgba(0, 0, 0, 0.05);
    }

    .dark-mode .action-btn:hover {
        background: rgba(255, 255, 255, 0.1);
    } */

  /* Full screen button with tooltip */
  .full-screen-btn {
    position: relative;
  }

  .full-screen-btn .tooltip {
    position: absolute;
    bottom: 120%; /* Position above button */
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8); /* Darker tooltip background */
    color: white;
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 0.75rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease-in-out;
    z-index: 100;
    margin-bottom: 8px;
  }

  .full-screen-btn:hover .tooltip {
    opacity: 1;
  }

  /* Chat Container Styles */
  .chat-container {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    background-color: var(--chat-bg);
    color: #fefeff;
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) var(--chat-bg);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 10px; /* Spacing between messages */
    font-size: 1rem;
    line-height: 1.6;
    scroll-behavior: smooth;
  }

  .chat-container::-webkit-scrollbar {
    width: 8px;
  }

  .chat-container::-webkit-scrollbar-track {
    background: var(--chat-bg);
    border-radius: 10px;
  }

  .chat-container::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 10px;
    border: 2px solid var(--chat-bg);
  }

  .chat-container::-webkit-scrollbar-thumb:hover {
    background-color: var(--primary-light);
  }

  /* Initial New Chat Screen */
  .new-chat-placeholder {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: var(--text-color);
    font-size: 1rem;
    text-align: center;
    padding-bottom: 100px; /* Space for the input area */
    gap: 5px;
  }
  .new-chat-placeholder .input-area {
    position: relative;
    bottom: 50%;
    margin-bottom: 1000px;
  }

  .new-chat-placeholder .title {
    font-size: 2rem;
    font-weight: 600;
    color: var(--text-color);
  }
  .new-chat-placeholder img {
    height: 60px;
    width: 60px;
    background-size: cover;
    background-repeat: no-repeat;
  }

  /* Individual Chat Message Styles */
  .chat-message {
    /* Max width to keep messages readable, centered in the chat container */
    max-width: 768px; /* Standard readable width for content */
    margin-left: auto; /* For user messages */
    margin-right: auto; /* For bot messages */
    padding: 16px 20px;
    border-radius: var(--border-radius);
    word-break: break-word;
    position: relative;
    background-color: var(--bot-message-bg);
    color: var(--text-color);
    font-size: 1rem;
    transition: var(--transition);
    box-shadow: var(--shadow);
    animation: fadeIn 0.3s ease-out; /* Fade in animation for new messages */
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* User Messages */
  .user-message {
    background-color: var(--user-message-bg);
    margin-left: auto;
    margin-right: 0; /* Adjusted for responsiveness */
    padding: 14px 18px;
    border-radius: 24px; /* Rounded with unique flair */
    max-width: 70%;
    font-weight: 500;
    color: #f0f0f0;
    line-height: 1.6;
    word-break: break-word;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    animation: slideInRight 0.25s ease-out;
    backdrop-filter: blur(6px);
  }

  /* Bot Messages */
  .bot-message {
    background-color: var(--bot-message-bg);
    margin-right: auto;
    margin-left: 0; /* Adjusted for responsiveness */
    padding: 14px 18px;
    border-radius: 12px 12px 12px 4px;
    border: none;
    max-width: 100%;
    color: black;
    font-weight: 400;
    line-height: 1.6;
    word-break: break-word;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    animation: slideInLeft 0.25s ease-out;
    backdrop-filter: blur(6px);
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
  }
  @media (max-width: 768px) {
    .bot-message {
      max-width: 100%;
    }
  }
  /* Animations */
  @keyframes slideInRight {
    from {
      opacity: 0;
      transform: translateX(10px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  @keyframes slideInLeft {
    from {
      opacity: 0;
      transform: translateX(-10px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .message-header {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 0.9em;
    color: var(--text-light); /* Make header text slightly lighter */
  }

  .message-timestamp {
    font-weight: normal;
    font-size: 0.8em;
    opacity: 0.7;
    margin-left: auto; /* Push timestamp to the right */
    color: var(--text-light);
    display: none;
  }

  .message-header i {
    margin-right: 8px;
    color: var(--primary-color);
  }

  .message-content {
    margin-top: 10px;
    color: var(--text-color);
  }

  .message-content p {
    margin-bottom: 10px; /* Space between paragraphs in messages */
  }

  .message-content p:last-child {
    margin-bottom: 0; /* No extra margin on last paragraph */
  }

  /* Code Block Styles */
  /* ===== CODE BLOCK STYLE ===== */
  .code-block {
    background-color: #1e1e1e; /* Dark editor-like background */
    border-radius: 6px;
    margin: 1rem 0;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    border: 1px solid #333;
  }

  .code-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #252526; /* Slightly darker header */
    padding: 8px 12px;
    color: #9cdcfe; /* VS Code-like blue text */
    font-size: 0.85rem;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    border-bottom: 1px solid #1a1a1a;
  }

  .code-language {
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .code-header-actions {
    display: flex;
    gap: 8px;
  }

  .code-header button {
    background: #3a3d41;
    border: none;
    color: #d4d4d4;
    padding: 4px 10px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.75rem;
    font-family: inherit;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .code-header button:hover {
    background: #2e2e2e;
    color: #ffffff;
  }

  .code-header button i {
    font-size: 0.8rem;
  }

  pre {
    background-color: #1e1e1e !important;
    padding: 16px !important;
    margin: 0 !important;
    overflow-x: auto;
    white-space: pre;
    tab-size: 2;
    line-height: 1.5;
  }

  code {
    font-family: "Cascadia Code", "Consolas", "Monaco", "Andale Mono",
      "Ubuntu Mono", monospace !important;
    font-size: 0.9rem !important;
    color: #d4d4d4 !important; /* Default text color */
  }

  /* ===== SYNTAX HIGHLIGHTING COLORS ===== */
  .token.comment,
  .token.prolog,
  .token.doctype,
  .token.cdata {
    color: #6a9955; /* Green */
  }

  .token.punctuation {
    color: #d4d4d4; /* Light gray */
  }

  .token.property,
  .token.tag,
  .token.boolean,
  .token.number,
  .token.constant,
  .token.symbol,
  .token.deleted {
    color: #b5cea8; /* Light green */
  }

  .token.selector,
  .token.attr-name,
  .token.string,
  .token.char,
  .token.builtin,
  .token.inserted {
    color: #ce9178; /* Orange */
  }

  .token.operator,
  .token.entity,
  .token.url,
  .language-css .token.string,
  .style .token.string {
    color: #d4d4d4; /* Light gray */
  }

  .token.atrule,
  .token.attr-value,
  .token.keyword {
    color: #569cd6; /* Blue */
  }

  .token.function,
  .token.class-name {
    color: #dcdcaa; /* Yellow */
  }

  .token.regex,
  .token.important,
  .token.variable {
    color: #d16969; /* Red */
  }

  /* ================================
✅ Improved ChatGPT-like Input Area
================================== */

  .input-area {
    padding: 10px; /* Adjusted padding */
    background-color: var(--chat-bg);
    position: sticky;
    bottom: 0;
    z-index: 10;
  }

  .input-container {
    display: flex;
    gap: 8px;
    width: 100%;
    max-width: 800px;
    margin: 0 auto; /* Centered */
    align-items: flex-end;
    position: relative;
    background: rgba(0, 0, 0, 0.03);
    border-radius: 28px;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
    padding: 10px 14px;
    border: 2px solid #4d5050;

    transition: box-shadow 0.2s ease;
  }

  .dark-mode .input-container {
    background: #313130;
    /* border: 1px solid #606060; */
    box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.1);
  }

  .main.full-screen .input-container {
    max-width: 900px;
  }
  .main.full-width .input-container {
    max-width: 835px;
  }
  /* .main.full-width { Applied when sidebar is collapsed on desktop
        margin-right:90px;
    } */

  /* ✅ Improved Text Input */
  /* ✨ Responsive Growing Textarea */
  #text-input {
    flex: 1;
    min-width: 0;
    max-width: 100%;
    padding: 10px 0px;
    text-align: start;
    z-index: 10;

    border: none;
    background: transparent;
    color: var(--text-color);
    font-size: 1.25rem;
    resize: none; /* Prevent manual resize */
    overflow-y: auto; /* Will scroll after max-height is reached */
    min-height: 90px;
    max-height: 200px; /* Stop growing after this */
    line-height: 1.5;
    border-radius: var(--border-radius-sm);
    transition: height 0.15s ease-in-out;
    white-space: pre-wrap;
    word-wrap: break-word;
    scrollbar-width: thin;
    scrollbar-color: #10a37f transparent;
  }

  /* ✅ Custom Scrollbar Styling for WebKit (Chrome, Edge, Safari) */
  #text-input::-webkit-scrollbar {
    width: 6px;
  }

  #text-input::-webkit-scrollbar-track {
    background: transparent;
  }

  #text-input::-webkit-scrollbar-thumb {
    background-color: #10a37f;
    border-radius: 3px;
    border: 1px solid transparent;
  }

  #text-input::-webkit-scrollbar-thumb:hover {
    background-color: #0e8e6e;
  }

  #text-input:focus {
    outline: none;
  }

  /* Glowing Input Container */
  .input-container {
    position: relative;
    z-index: 0;
    display: flex;
    align-items: center;
    border-radius: 28px;
  }

  .input-container::after {
    content: "";
    z-index: -1;
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: var(--chat-bg);
    left: 0;
    top: 0;
    border-radius: 28px;
  }




  /* .input-container:focus-within {
    box-shadow: 0 0 0 2px rgba(163, 16, 16, 0.25),
      inset 0 1px 2px rgba(186, 61, 61, 0.05);
  }
  .dark-mode .input-container:focus-within {
    box-shadow: 0 0 0 2px rgba(220, 102, 23, 0.25),
      inset 0 1px 2px rgba(255, 255, 255, 0.1);
  } */

  /* ✅ Bigger Icon Buttons */
  .input-icon-btn,
  .submit-btn,
  .stop-btn {
    background: none;
    border: none;
    color: #2d2d2c;

    cursor: pointer;
    font-size: 1.3rem;
    padding: 8px;
    margin-left: 0px;
    border-radius: 50%;
    transition: var(--transition);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 42px; /* Larger buttons */
    height: 42px;
    flex-shrink: 0;
  }
  /* .input-icon-btn{
background: rgba(0, 0, 0, 0.05);
} */

  .input-icon-btn:hover,
  .submit-btn:hover {
    background: rgba(0, 0, 0, 0.05);
    color: var(--text-color);
  }
  .dark-mode .input-icon-btn:hover,
  .dark-mode .submit-btn:hover {
    background: #424343;
    /* color: var(--text-color); */
    color: white;
  }
  .dark-mode .input-icon-btn,
  .dark-mode .submit-btn,
  .dark-mode.stop-btn {
    color: #e5e5e4;
  }
  /* Active Send Button */
  .submit-btn.active {
    background-color: #000000;
    color: white;
  }
  .dark-mode .submit-btn.active {
    background-color: white;
    color: black;
  }
  .submit-btn.active:hover {
    background-color: #5d5b5b;
  }

  /* Stop Button (visible when AI responds) */
  .stop-btn {
    display: none;
  }

  /* When the AI is responding, hide the send button and show the stop button */
  .input-container.ai-responding .send-btn {
    display: none;
  }

  .input-container.ai-responding .stop-btn {
    display: block;
  }
  .stop-btn:hover {
    background: rgba(255, 107, 107, 0.1);
  }

  /* Image Preview in Input Area */
  .image-preview-container {
    display: none; /* Hidden by default */
    flex-direction: column;
    gap: 10px;
    padding: 10px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    margin-bottom: 10px;
    align-items: flex-start;
    position: relative;
  }
  .dark-mode .image-preview-container {
    border-color: rgba(255, 255, 255, 0.1);
  }

  .image-preview-container img {
    max-width: 70px;
    max-height: 70px;
    border-radius: var(--border-radius-sm);
    object-fit: contain;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: var(--shadow);
  }
  .dark-mode .image-preview-container img {
    border-color: rgba(255, 255, 255, 0.1);
  }

  .clear-image-btn {
    position: absolute;
    top: 5px;
    left: 65px;
    background: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    cursor: pointer;
    transition: background 0.2s;
  }
  .clear-image-btn:hover {
    background: rgba(0, 0, 0, 0.8);
  }

  /* Responsive adjustments for input */
  @media (max-width: 768px) {
    .input-container {
      flex-wrap: nowrap; /* Keep on one line for mobile too */
      align-items: flex-end;
      padding-right: 1px;
      padding-left: 1px;
    }

    #text-input {
      flex: 1;
      min-height: 88px; /* Adjusted min-height for mobile */
      padding: 0px 0px;
      font-size: 18px;
    }

    .submit-btn,
    .stop-btn {
      width: 38px;
      height: 38px;
      padding: 0px;
    }

    /* Adjust spacing when voice mode is active */
    .input-container.voice-active #voice-talk-btn {
      order: 1;
      margin-right: 4px; /* Space between mic and indicator */
      margin-left: 20px;
      padding-left: 20px; /* Remove auto-margin */
    }

    .input-container.voice-active .voice-indicator-area {
      flex: 1 1 auto; /* Take remaining horizontal space */
      order: 2;
    }
    /* Hide full-screen toggle button on mobile */
    .top-bar-actions .full-screen-btn {
      display: none;
    }
  }
  @media (max-width: 768px) {
    .input-icon-btn {
      width: 38px;
      height: 38px;
      padding: 4px;
    }
  }

  /* Loading Indicator */
  .loader {
    display: none; /* Hidden by default */
    padding: 16px;
    text-align: center;
    color: var(--text-color);
    font-size: 0.95rem;
    opacity: 0.7;
    animation: fadeIn 0.3s ease-in-out;
  }

  .typing-indicator {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 6px;
    padding: 12px;
    height: 32px;
    animation: fadeIn 0.3s ease-in-out;
  }

  .typing-dot {
    width: 8px;
    height: 8px;
    background-color: var(--primary-color, #2563eb);
    border-radius: 50%;
    opacity: 0.4;
    animation: typingDotAnimation 1.4s infinite ease-in-out;
  }

  .typing-dot:nth-child(2) {
    animation-delay: 0.2s;
  }

  .typing-dot:nth-child(3) {
    animation-delay: 0.4s;
  }

  @keyframes typingDotAnimation {
    0%,
    80%,
    100% {
      transform: scale(0.8);
      opacity: 0.4;
    }
    40% {
      transform: scale(1);
      opacity: 1;
    }
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(5px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .typing-dot:nth-child(1) {
    animation-delay: 0s;
  }

  .typing-dot:nth-child(2) {
    animation-delay: 0.2s;
  }

  .typing-dot:nth-child(3) {
    animation-delay: 0.4s;
  }

  /* Enhanced Typing Animation */
  @keyframes typingAnimation {
    0%,
    80%,
    100% {
      transform: translateY(0);
      opacity: 0.4;
    }
    40% {
      transform: translateY(-8px);
      opacity: 1;
    } /* More pronounced bounce */
  }

  /* Special Message Components */
  .message-section {
    margin-bottom: 16px;
  }

  .section-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--primary-color);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .section-title i {
    font-size: 0.9rem;
  }

  .example-item {
    background: rgba(0, 0, 0, 0.05);
    padding: 10px 12px;
    border-radius: 6px;
    margin-bottom: 8px;
    border-left: 3px solid var(--primary-color);
    transition: var(--transition);
  }

  .example-item:hover {
    background: rgba(0, 0, 0, 0.08);
  }

  .dark-mode .example-item {
    background: rgba(255, 255, 255, 0.05);
  }

  .dark-mode .example-item:hover {
    background: rgba(255, 255, 255, 0.08);
  }

  .example-title {
    font-weight: 500;
    margin-bottom: 5px;
  }

  .message-with-image {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .message-images-container {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    margin-top: 10px;
  }

  .message-images-container img {
    max-width: 100%;
    max-height: 300px;
    border-radius: var(--border-radius-sm);
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: var(--shadow);
    object-fit: contain;
  }

  .dark-mode .message-images-container img {
    border-color: rgba(255, 255, 255, 0.1);
  }

  .uploaded-image-preview {
    max-width: 100%;
    max-height: 300px;
    border-radius: var(--border-radius-sm);
    margin-top: 10px;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: var(--shadow);
    object-fit: contain;
  }

  .dark-mode .uploaded-image-preview {
    border-color: rgba(255, 255, 255, 0.1);
  }

  /* Camera Options (for mobile) */
  .camera-options {
    display: none; /* Hidden by default, shown on mobile for image upload */
    position: fixed;
    bottom: 80px; /* Position above the input area */
    left: 0;
    right: 0;
    background: var(
      --sidebar-bg
    ); /* Use sidebar background for consistency */
    padding: 16px;
    border-radius: 16px 16px 0 0; /* Rounded top corners */
    box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    animation: slideUp 0.3s ease-out; /* Slide up animation */
  }

  @keyframes slideUp {
    from {
      transform: translateY(100%);
    }
    to {
      transform: translateY(0);
    }
  }

  .camera-option {
    padding: 14px;
    margin: 8px 0;
    background: var(--primary-color);
    color: white;
    border-radius: var(--border-radius-sm);
    text-align: center;
    cursor: pointer;
    transition: var(--transition);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    font-weight: 500;
    position: relative; /* For the hidden input */
    overflow: hidden; /* Hide the overflow of the input */
  }
  .camera-option:hover {
    background: var(--primary-light);
  }
  .camera-option.cancel {
    background: #ff6b6b; /* Red for cancel */
  }
  .camera-option.cancel:hover {
    background: #e65a5a;
  }

  /* Make hidden file inputs fill their parent .camera-option */
  .camera-option input[type="file"] {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0; /* Make it completely transparent */
    cursor: pointer;
    z-index: 1; /* Ensure it's clickable above the div content */
  }

  /* Message Actions (e.g., Summarize) */
  .message-actions {
    margin-top: 12px;
    display: flex;
    gap: 8px;
    justify-content: flex-end; /* Align actions to the right */
    display: none;
  }

  .message-action-btn {
    background: rgba(
      0,
      0,
      0,
      0.05
    ); /* Light background for action buttons */
    color: var(--text-color);
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-size: 0.85rem;
    transition: var(--transition);
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .dark-mode .message-action-btn {
    background: rgba(255, 255, 255, 0.1);
  }

  .message-action-btn:hover {
    background: rgba(0, 0, 0, 0.1);
  }
  .dark-mode .message-action-btn:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  /* Confirmation Modal Styles */
  .modal {
    display: none; /* Hidden by default */
    position: fixed;
    z-index: 1000;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.6);
    animation: fadeIn 0.2s ease-out;
  }

  .modal-content {
    background: var(--chat-bg);
    padding: 24px;
    border-radius: var(--border-radius);
    max-width: 90%;
    width: 400px;
    text-align: center;
    box-shadow: var(--shadow-md);
  }

  .modal-content h3 {
    margin-top: 0;
    margin-bottom: 16px;
    color: var(--text-color);
    font-size: 1.2rem;
  }

  .modal-content p {
    margin-bottom: 24px;
    color: var(--text-light);
  }

  .modal-buttons {
    display: flex;
    justify-content: center;
    gap: 12px;
  }

  .modal-btn {
    padding: 10px 20px;
    border: none;
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    font-weight: 500;
    transition: var(--transition);
    flex: 1; /* Distribute space evenly */
    max-width: 120px; /* Max width for buttons */
  }

  .modal-btn.confirm {
    background-color: #ff6b6b; /* Red for destructive action */
    color: white;
  }

  .modal-btn.confirm:hover {
    background-color: #e65a5a;
  }

  .modal-btn.cancel {
    background-color: rgba(0, 0, 0, 0.05);
    color: var(--text-color);
  }

  .dark-mode .modal-btn.cancel {
    background-color: rgba(255, 255, 255, 0.1);
  }

  .modal-btn.cancel:hover {
    background-color: rgba(0, 0, 0, 0.1);
  }
  .dark-mode .modal-btn.cancel:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  /* Full screen mode adjustments */
  body.full-screen-mode .sidebar {
    transform: translateX(-100%);
  }

  body.full-screen-mode .main {
    margin-left: 0;
    width: 100%;
  }

  body.full-screen-mode #showSidebarBtn {
    display: flex; /* Show floating button when in full screen */
  }

  /* Tooltip (general) */
  .tooltip-container {
    position: relative;
    display: inline-block;
  }

  .tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(
      0,
      0,
      0,
      0.8
    ); /* Tooltip background matches text color */
    color: white; /* Tooltip text matches background color */
    padding: 6px 12px;
    border-radius: 4px;
    font-size: 0.75rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s;
    z-index: 100;
    margin-bottom: 8px;
  }

  .tooltip-container:hover .tooltip {
    opacity: 1;
  }

  /* Gradient accent for some elements (if desired) */
  .gradient-accent {
    background: linear-gradient(
      135deg,
      var(--primary-color),
      var(--primary-light)
    );
  }

  /* Pulse animation for new messages */
  @keyframes pulse {
    0% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.01);
    } /* Subtle pulse */
    100% {
      transform: scale(1);
    }
  }

  .pulse {
    animation: pulse 0.5s ease;
  }
  /* Style for model selection toggle */
  .model-select-group {
display: flex;
justify-content: center;
gap: 12px;
padding: 0.5rem 0;
flex-wrap: wrap; /* Allows wrapping on small screens */
}

/* Base style: use Web Search button style for both */
.model-option,
#web-search-btn {
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
padding: 6px 10px;       /* slightly smaller than before */
border: 1px solid var(--web-search); /* same as web search btn */
border-radius: 30px;
font-size: 0.9rem;        /* slightly smaller text */
font-weight: 500;
color: var(--text-color);
background-color: var(--bg-color);
cursor: pointer;
transition: all 0.25s ease;
text-align: center;
line-height: 1;
min-width: 100px;          /* slightly smaller width */
user-select: none;
}

/* Active DeepThink toggle */
.model-option[data-active="true"] {
background: var(--accent-color);
border-color: var(--accent-color);
color: var(--model-text-color);
box-shadow: 0 2px 6px rgba(16, 163, 127, 0.3);
}

/* Hover effect (desktop only) */
@media (hover: hover) {
/* .model-option:hover, */
#web-search-btn:hover {
background-color: rgba(16, 163, 127, 0.06);
border-color: var(--primary-color);
}
}

/* Icons */
.model-option svg,
#web-search-btn svg {
width: 18px;   /* slightly smaller */
height: 18px;
flex-shrink: 0;
display: block;
fill: currentColor;
}

/* Text inside buttons */
.model-option span,
#web-search-btn span {
font-size: 0.9rem;
font-weight: 500;
color: var(--text-color);
}

/* Mobile adjustments */
@media (max-width: 480px) {
.model-option,
#web-search-btn {
    font-size: 12px;
    padding: 5px 10px;
    gap: 6px; /* take equal space if multiple buttons */
}

.model-option i,
#web-search-btn svg {
width: 16px;
height: 16px;
}

.model-option span,
#web-search-btn span {
font-size: 0.8rem;
}
}
.model-option[data-active="true"] i {
color: var(--model-text-color); /* primary accent */
animation: pulse 1.5s infinite;
}

@keyframes pulse {
0% { transform: scale(1); opacity: 0.8; }
50% { transform: scale(1.15); opacity: 1; }
100% { transform: scale(1); opacity: 0.8; }
}



  /* NEW: Voice Mode Overlay Styles */
  #voice-mode-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #202123; /* Dark background similar to ChatGPT */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000; /* Ensure it's on top */
    color: white;
    transition: opacity 0.3s ease;
    opacity: 0;
    pointer-events: none; /* Initially non-interactive */
  }

  #voice-mode-overlay.active {
    opacity: 1;
    pointer-events: auto; /* Make interactive when active */
  }

  #voice-mode-overlay .status-text {
    font-size: 1.1rem;
    margin-bottom: 20px;
    color: #a0a0a0; /* Lighter grey for status */
  }

  #voice-mode-overlay .control-buttons {
    position: absolute;
    bottom: 50px; /* Position at the bottom */
    display: flex;
    gap: 20px;
  }

  #voice-mode-overlay .control-button {
    background-color: #404040; /* Darker grey for buttons */
    color: white;
    border: none;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 1.8rem;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    transition: background-color 0.2s ease, transform 0.2s ease;
  }

  #voice-mode-overlay .control-button:hover {
    background-color: #555;
    transform: translateY(-2px);
  }

  #voice-mode-overlay .control-button.mic-active {
    background-color: var(--primary-color); /* Green when active */
  }
  #voice-mode-overlay .control-button.mic-active:hover {
    background-color: var(--primary-light);
  }

  #voice-mode-overlay .control-button.screen-share-active {
    background-color: #ff6b6b; /* Red for active screen share */
  }
  #voice-mode-overlay .control-button.screen-share-active:hover {
    background-color: #e65a5a;
  }

  #voice-circle-canvas {
    background-color: transparent; /* Canvas background */
    border-radius: 50%; /* Make it circular */
    /* Initial size, will be dynamic */
    width: 200px;
    height: 200px;
    max-width: 80vw; /* Responsive sizing */
    max-height: 80vw;
  }

  /* NEW: Screen Share Preview Container */
  #screen-share-preview-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8); /* Dark overlay */
    z-index: 999; /* Below voice mode overlay */
    display: none; /* Hidden by default */
    justify-content: center;
    align-items: center;
  }

  #screen-share-preview-video {
    max-width: 90%;
    max-height: 90%;
    border: 2px solid var(--primary-color);
    border-radius: var(--border-radius);
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
  }

  /* NEW: Code Update Modal */
  #codeUpdateModal {
    display: none; /* Hidden by default */
    position: fixed;
    z-index: 1001; /* Above other modals */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
  }

  #codeUpdateModal .modal-content {
    max-width: 800px;
    width: 90%;
    height: 80%;
    display: flex;
    flex-direction: column;
    padding: 20px;
  }

  #codeUpdateModal textarea {
    flex: 1;
    width: 100%;
    min-height: 150px;
    padding: 10px;
    margin-bottom: 15px;
    border: 1px solid var(--text-light);
    border-radius: var(--border-radius-sm);
    background-color: var(--code-bg);
    color: var(--code-text-color);
    font-family: "Fira Code", monospace;
    font-size: 0.9rem;
    resize: vertical;
  }

  #codeUpdateModal select {
    padding: 8px;
    margin-bottom: 15px;
    border-radius: var(--border-radius-sm);
    border: 1px solid var(--text-light);
    background-color: var(--bg-color);
    color: var(--text-color);
  }

  /* New CSS for ChatGPT-like talking animation (when AI is speaking) */
  #talking-animation {
    position: fixed;
    bottom: 90px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    padding: 10px 18px;
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 999px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    color: white;
    font-size: 0.9rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-in-out;
    z-index: 999;
  }

  #talking-animation.active {
    opacity: 1;
  }

  .talking-animation-bars {
    display: flex;
    align-items: center;
    gap: 4px;
  }

  .talking-bar {
    width: 4px;
    height: 16px;
    background-color: #10a37f;
    border-radius: 2px;
    transform-origin: bottom;
    animation: barWave 1.2s infinite ease-in-out;
    opacity: 0.7;
  }

  .talking-bar:nth-child(1) {
    animation-delay: 0s;
  }
  .talking-bar:nth-child(2) {
    animation-delay: 0.1s;
  }
  .talking-bar:nth-child(3) {
    animation-delay: 0.2s;
  }
  .talking-bar:nth-child(4) {
    animation-delay: 0.3s;
  }
  .talking-bar:nth-child(5) {
    animation-delay: 0.4s;
  }

  @keyframes barWave {
    0%,
    100% {
      transform: scaleY(0.6);
      opacity: 0.5;
    }
    50% {
      transform: scaleY(1.4);
      opacity: 1;
    }
  }
  body {
    font-family: "Inter";
  }

  /* Enhanced Chat Container */
  .chat-container {
    flex: 1;
    width: 100%;
    max-width: 800px;
    padding: 20px 0;
    overflow-y: auto;
    background-color: var(--chat-bg);
    color: #fefeff;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    gap: 10px;
    font-size: 1rem;
    line-height: 1.6;
    scroll-behavior: smooth;
    margin: 0 auto;
    position: relative;
    transition: all 0.3s ease;
  }

  /* Improved scrollbar for WebKit browsers (Chrome, Safari, Edge) */
  .chat-container::-webkit-scrollbar {
    width: 10px;
  }

  .chat-container::-webkit-scrollbar-track {
    background: transparent;
    border-radius: 10px;
    margin: 5px 0;
  }

  .chat-container::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    border: 2px solid transparent;
    background-clip: padding-box;
  }

  .chat-container::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
    border: 2px solid transparent;
    background-clip: padding-box;
  }

  .dark-mode .chat-container::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
  }

  .dark-mode .chat-container::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }

  /* Improved scrollbar for Firefox */
  .chat-container {
    scrollbar-width: thin;
    scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
  }

  .dark-mode .chat-container {
    scrollbar-color: rgba(255, 255, 255, 0.2) transparent;
  }

  /* Chat container adjustments when sidebar is open */
  .sidebar:not(.collapsed) + .main .chat-container {
    max-width: 800px;
    padding: 20px 15px;
  }

  /* Chat container adjustments when sidebar is collapsed */
  .sidebar.collapsed + .main .chat-container {
    max-width: 900px;
    padding: 20px 25px;
  }

  /* Mobile adjustments */
  @media (max-width: 768px) {
    .chat-container {
      max-width: 100%;
      padding: 15px 10px;
    }

    .sidebar:not(.collapsed) + .main .chat-container,
    .sidebar.collapsed + .main .chat-container {
      max-width: 100%;
      padding: 15px 10px;
    }
  }

  /* Enhanced message styling for better appearance */
  .user-message {
    background-color: var(--user-message-bg);
    margin-left: auto;
    margin-right: 0;
    padding: 14px 18px;
    border-radius: 24px;
    max-width: 70%;
    font-weight: 500;
    color: #111827;
    line-height: 1.6;
    word-break: break-word;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    animation: slideInRight 0.25s ease-out;
    backdrop-filter: blur(6px);
  }

  .bot-message {
    background-color: var(--bot-message-bg);
    margin-right: auto;
    margin-left: 0;
    padding: 14px 18px;
    border-radius: 18px 18px 4px 18px; 
    border: none;
    max-width: 100%;
    color: black;
    font-weight: 400;
    line-height: 1.6;
    word-break: break-word;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    animation: slideInLeft 0.25s ease-out;
    backdrop-filter: blur(6px);
    background: transparent !important;
    box-shadow: none !important;
    border: none !important;
  }

  /* Add subtle border to messages in dark mode */
  .dark-mode .user-message {
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .dark-mode .bot-message {
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  /* Adjust message width based on sidebar state */
  .sidebar:not(.collapsed) + .main .user-message,
  .sidebar:not(.collapsed) + .main .bot-message {
    max-width: 75%;
  }

  .sidebar.collapsed + .main .user-message,
  .sidebar.collapsed + .main .bot-message {
    max-width: 85%;
  }

  @media (max-width: 768px) {
    .user-message,
    .bot-message {
      max-width: 90% !important;
    }
  }

/* Improved Input Container */
.input-container {
display: flex;
flex-direction: column;
width: 100%;
margin: 0 auto;
position: relative;
background: rgba(0, 0, 0, 0.03);
border-radius: 28px;
box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
padding: 14px;
border: 2px solid #3536361e;
transition: box-shadow 0.2s ease;
box-sizing: border-box;
min-height: 130px;
}

.dark-mode .input-container {
background: #313130;
border: 1px solid #3f3e3e;
box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.1);
}

/* Textarea that takes full width and height above icons */
#text-input {
width: 100%;
padding: 0;
text-align: start;
border: none;
background: transparent;
color: var(--text-color);
font-size: 1.25rem;
resize: none;
overflow-y: auto;
min-height: 30px;
line-height: 1.5;
max-height: 150px;
border-radius: var(--border-radius-sm);
transition: var(--transition);
white-space: pre-wrap;
word-wrap: break-word;
scrollbar-width: thin;
scrollbar-color: var(--primary-color) transparent;
flex: 1;
margin-bottom: 8px;
}

/* Container for icons at the bottom */
.input-icons-row {
display: flex;
align-items: center;
justify-content: space-between;
width: 100%;
height: 38px;
}

/* Left and right side icons */
.input-icons-left,
.input-icons-right {
display: flex;
gap: 12px; /* smaller gap for mobile-friendliness */
align-items: center;
}

/* Icon buttons (mic, send, stop, file) */
.input-icon-btn,
.submit-btn,
.stop-btn {
background: none;
border: none;
color: var(--text-color);
cursor: pointer;
font-size: 1.3rem;
padding: 8px;
border-radius: 50%;
transition: all 0.2s ease;
display: flex;
align-items: center;
justify-content: center;
width: 44px;
height: 44px;
flex-shrink: 0;
position: relative;
}

/* Hover & active effects */
.input-icon-btn:hover,
.submit-btn:hover,
.stop-btn:hover {
background: rgba(0, 0, 0, 0.05);
}

.dark-mode .input-icon-btn:hover,
.dark-mode .submit-btn:hover {
background: #424343;
color: white;
}

.submit-btn.active {
background-color: #000;
color: white;
}

.dark-mode .submit-btn.active {
background-color: white;
color: black;
}

/* File input covering button */
.file-input-wrapper {
position: relative;
display: inline-block;
}

.file-input-wrapper input[type="file"] {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
opacity: 0;
cursor: pointer;
z-index: 2;
font-weight: 600;
}

/* Voice indicator area */
.voice-indicator-area {
display: none;
flex-direction: column;
align-items: center;
justify-content: center;
background: transparent;
border-radius: var(--border-radius-sm);
padding: 6px 0;
gap: 4px;
width: 100%;
}

/* Show voice area when active */
.input-container.voice-active .voice-indicator-area {
display: flex;
}

/* Mobile adjustments */
@media (max-width: 768px) {
.input-container {
padding: 10px 12px;
min-height: 50px;
}

#text-input {
font-size: 1.1rem;
min-height: 10px;
max-height: 120px;
margin-bottom: 6px;
}

.input-icon-btn,
.submit-btn,
.stop-btn {
width: 38px;
height: 38px;
font-size: 1.1rem;
padding: 6px;
}

.input-icons-left,
.input-icons-right {
gap: 8px; /* smaller gap for smaller screens */
}
}

/* Focus effect */
.input-container {
cursor: text;
}

/* .input-container:focus-within {
box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.25),
inset 0 1px 2px rgba(0, 0, 0, 0.05);
} */
/* 
.dark-mode .input-container:focus-within {
box-shadow: 0 0 0 2px rgba(16, 163, 127, 0.25),
inset 0 1px 2px rgba(255, 255, 255, 0.1);
} */

/* Loader positioning */
.loader {
padding: 16px;
text-align: center;
color: var(--text-color);
font-size: 0.95rem;
opacity: 0.7;
animation: fadeIn 0.3s ease-in-out;
margin: 20px auto;
max-width: 768px;
width: 100%;
}

.chat-container .loader {
align-self: center;
margin-left: 0;
margin-right: 0;
}
/* "Thinking" Message & Dots */
.thinking-message {
    font-size: 1.25rem;
    color: var(--text-color);
    margin: 1rem 0;
    padding: 10px;
    border-radius: 10px;
    width: fit-content;
    display: flex;
    gap: 0.5rem;
    align-items: center;
    background-color: var(--bot-message-bg);
    animation: fadeIn 0.3s ease-in-out;
}

.thinking-dot {
    display: inline-block;
    width: 10px;
    height: 10px;
    background-color: var(--primary-color);
    border-radius: 50%;
    animation: thinkingDot 1.4s infinite ease-in-out;
}

.thinking-dot:nth-child(2) {
    animation-delay: 0.2s;
}

.thinking-dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes thinkingDot {
    0%, 80%, 100% {
        transform: scale(0);
        opacity: 0.4;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}
@media (max-width: 768px) {
  .input-container {
    flex-wrap: nowrap;
    align-items: flex-end;
    /* FIX 1: Set horizontal padding to 0, rely on .input-area padding */
    padding: 10px 0; 
    height: 125px;
  }

  #text-input {
    flex: 1;
    min-height: 10px;
    padding: 0px 0px 10px 10px;
    font-size: 18px;
  }
  
  /* FIX 2: Reduce button/icon size for safety on narrowest devices */
  .submit-btn, .stop-btn {
    width: 34px; 
    height: 34px;
    padding: 0;
    margin-right: 10px;
  }
  
  .input-icon-btn {
    width: 34px; 
    height: 34px;
    padding: 4px;
    padding-left: 10px;
  }

  /* ... rest of your mobile styles ... */
}
  

      
      /* CSS Variables for ChatGPT-like theming */
      
/* Web Search Button matching DeepThink size */


    </style>
  </head>
  <body>
    <div id="talking-animation">
      Talking
      <div class="talking-animation-bars">
        <span class="talking-bar"></span>
        <span class="talking-bar"></span>
        <span class="talking-bar"></span>
        <span class="talking-bar"></span>
        <span class="talking-bar"></span>
      </div>
    </div>

    <div id="sidebar" class="sidebar">
      <div class="sidebar-header">
        <div class="sidebar-logo">
          <!-- <i class="fas fa-robot"></i> -->
          <img src="/static/images/vexara-new1-removebg-preview.png" alt="V" />
          <span style="font-family: 'Baskerville'"><h3 >Vexara</h3></span>
        </div>
        <!-- Renamed hideSidebarBtn to sidebarToggleButton for general use -->
        <!-- In your HTML -->
        <button
          id="sidebarToggleButton"
          class="sidebar-toggle"
          title="Toggle Sidebar"
          aria-label="Toggle Sidebar"
        >
          <i class="bx bx-layout"></i>
        </button>
      </div>

      <button
        class="new-chat-btn"
        onclick="startNewChat()"
        \
        aria-label="Start New Chat"
      >
        <i class="fa-solid fa-plus"></i>
        <span>New Chat</span>
      </button>

      <div
        id="chat-history-list"
        role="navigation"
        aria-label="Chat History"
      ></div>

      <div class="sidebar-footer">
        <div
          id="user-info"
          class="user-info"
          style="display: none"
          role="contentinfo"
        >
          <i class="fas fa-user-circle" aria-hidden="true"></i>
          <span id="user-email" class="user-email"></span>
        </div>
        <button
          class="sidebar-btn"
          onclick="toggleDarkMode()"
          title="Toggle Dark Mode"
          aria-label="Toggle Dark Mode"
        >
          <i class="fas fa-moon" aria-hidden="true"></i>
          <span>Dark Mode</span>
        </button>
        <button
          class="sidebar-btn"
          id="clearAllChatsBtn"
          title="Clear All Chat History"
          aria-label="Clear All Chat History"
        >
          <i class="fas fa-trash" aria-hidden="true"></i>
          <span>Clear All Chats</span>
        </button>
        <a
          href="/logout"
          class="sidebar-btn"
          style="color: #ff6b6b"
          title="Logout"
          aria-label="Logout"
        >
          <i class="fas fa-sign-out-alt" aria-hidden="true"></i>
          <span>Logout</span>
        </a>
      </div>
    </div>

    <!-- Floating button to show sidebar on mobile or in full screen mode -->
    <button
      id="showSidebarBtn"
      class="sidebar-show-btn"
      title="Show Sidebar"
      aria-label="Toggle Sidebar"
    >
      <i class="fi fi-rr-sidebar"></i>
    </button>

    <div class="main">
      <div class="top-bar" style="display: flex;
          align-items: center;
          justify-content: left;" >
        <h2 style="font-weight: 450; font-style:'Baskerville';" >Vexara</h2> 
        <div class="top-bar-title">
          
          <i class="fa-solid fa-plus new-chat-btn" onclick="startNewChat()"></i>
        </div>
      </div>

      <div class="chat-container" id="chatbox" role="log" aria-live="polite">
        <!-- Initial New Chat Placeholder -->
        <div id="new-chat-placeholder" style="display: flex; align-items: center; gap: 8px; font-family: 'Segoe UI', 'Inter', sans-serif; font-size: 24px; font-weight: 600; color: #e5e5e5;">
          <img src="/static/images/vexara-new1-removebg-preview.png" alt="V" style="width: 40px; height: 40px; object-fit: contain; filter: hue-rotate(220deg);" />
          <span>How can I help you?</span>
        </div>
        
          <div class="loader" id="loader" aria-live="polite" aria-atomic="true" style="display: none">
    <div class="typing-indicator">
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
      <div class="typing-dot"></div>
    </div>
  </div>

      </div>

      <!-- Input Area at the bottom -->
      <div class="input-area">
        <!-- Image Preview Container -->
        <div
          id="image-preview-container"
          class="image-preview-container"
          aria-live="polite"
          aria-atomic="true"
        >
          <img
            id="image-preview"
            src="#"
            alt="Image Preview"
            style="display: none"
          />
          <button
            id="clear-image-btn"
            class="clear-image-btn"
            title="Clear Image"
            aria-label="Clear Image Preview"
          >
            <i class="fas fa-times" aria-hidden="true"></i>
          </button>
        </div>

        <form id="multi-action-form" enctype="multipart/form-data">
          <!-- Model Selection Buttons -->

          <div class="input-container" id="input-container">
            <textarea 
              id="text-input"
              name="instruction"
              placeholder="Ask Vexara"
              rows="1"
              required
              aria-label="Type your message here"
            ></textarea>

            <div class="input-icons-row">
              <div class="input-icons-left">
                <!-- Attachment button with proper file input -->
                <div class="file-input-wrapper">
                  <button
                    type="button"
                    class="input-icon-btn"
                    id="attach-file-btn"
                    title="Attach File"
                    aria-label="Attach File"
                  >
                    <svg width="22" height="26" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5.5498 9.75006V5.00006H6.9502V9.75006C6.9502 10.33 7.4201 10.7999 8 10.7999C8.5799 10.7999 9.0498 10.33 9.0498 9.75006V4.50006C9.0498 2.95366 7.7964 1.70026 6.25 1.70026C4.7036 1.70026 3.4502 2.95366 3.4502 4.50006V9.75006C3.4502 12.263 5.4871 14.2999 8 14.2999C10.5129 14.2999 12.5498 12.263 12.5498 9.75006V4.00006H13.9502V9.75006C13.9502 13.0362 11.2861 15.7003 8 15.7003C4.71391 15.7003 2.0498 13.0362 2.0498 9.75006V4.50006C2.04981 2.18047 3.9304 0.299867 6.25 0.299866C8.5696 0.299866 10.4502 2.18046 10.4502 4.50006V9.75006C10.4502 11.1032 9.3531 12.2003 8 12.2003C6.6469 12.2003 5.5498 11.1032 5.5498 9.75006Z" fill="currentColor"></path></svg>
                  </button>
                  <!-- Hidden file input, now outside the button for precise control -->
                  <input
                    type="file"
                    id="desktop-file-input"
                    name="image"
                    accept="image/*"
                    style="display: none"
                    aria-label="Upload image file"
                  />
                </div>
                <div class="model-select-group" aria-label="Toggle DeepThink Mode">
                  <!-- Hidden General Option (keeps backend happy) -->
                  <input
                    type="radio"
                    id="modelGeneral"
                    name="modelChoice"
                    value="general"
                    checked
                    aria-checked="true"
                    style="display:none;"
                  />
                
                  <!-- Visible DeepThink Toggle -->
                  <div class="model-option" id="deepthink-toggle" data-active="false">
                    <svg width="20" height="24" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon" aria-label=""><path d="M14.3352 10.0257C14.3352 7.6143 12.391 5.66554 10.0002 5.66537C7.60929 5.66537 5.66528 7.61419 5.66528 10.0257C5.66531 11.5493 6.44221 12.8881 7.61938 13.6683H12.3811C13.558 12.8881 14.3352 11.5491 14.3352 10.0257ZM8.84399 16.9984C9.07459 17.3983 9.50543 17.6683 10.0002 17.6683C10.495 17.6682 10.926 17.3984 11.1565 16.9984H8.84399ZM8.08813 15.6683H11.9114V14.9984H8.08813V15.6683ZM1.66626 9.33529L1.80103 9.34896C2.10381 9.41116 2.3313 9.67914 2.3313 10.0003C2.33115 10.3214 2.10377 10.5896 1.80103 10.6517L1.66626 10.6654H0.833252C0.466091 10.6654 0.168389 10.3674 0.168213 10.0003C0.168213 9.63306 0.465983 9.33529 0.833252 9.33529H1.66626ZM19.1663 9.33529L19.301 9.34896C19.6038 9.41116 19.8313 9.67914 19.8313 10.0003C19.8311 10.3214 19.6038 10.5896 19.301 10.6517L19.1663 10.6654H18.3333C17.9661 10.6654 17.6684 10.3674 17.6682 10.0003C17.6682 9.63306 17.966 9.33529 18.3333 9.33529H19.1663ZM3.0481 3.04818C3.2753 2.82099 3.62593 2.79189 3.88403 2.96224L3.98853 3.04818L4.57739 3.63705L4.66235 3.74154C4.83285 3.99966 4.80464 4.35021 4.57739 4.57748C4.35013 4.80474 3.99958 4.83293 3.74146 4.66244L3.63696 4.57748L3.0481 3.98861L2.96216 3.88412C2.79181 3.62601 2.82089 3.27538 3.0481 3.04818ZM16.012 3.04818C16.2717 2.7886 16.6927 2.78852 16.9524 3.04818C17.2117 3.30786 17.2119 3.72901 16.9524 3.98861L16.3625 4.57748C16.1028 4.83717 15.6818 4.83718 15.4221 4.57748C15.1626 4.31776 15.1625 3.89669 15.4221 3.63705L16.012 3.04818ZM9.33521 1.66634V0.833336C9.33521 0.466067 9.63297 0.168297 10.0002 0.168297C10.3674 0.168472 10.6653 0.466175 10.6653 0.833336V1.66634C10.6653 2.0335 10.3674 2.33121 10.0002 2.33138C9.63297 2.33138 9.33521 2.03361 9.33521 1.66634ZM15.6653 10.0257C15.6653 11.9571 14.7058 13.6634 13.2415 14.6917V16.3333C13.2415 16.7004 12.9444 16.9971 12.5774 16.9974C12.282 18.1473 11.2423 18.9982 10.0002 18.9984C8.75792 18.9984 7.71646 18.1476 7.42114 16.9974C7.05476 16.9964 6.75806 16.7 6.75806 16.3333V14.6917C5.29383 13.6634 4.33523 11.957 4.33521 10.0257C4.33521 6.88608 6.86835 4.33529 10.0002 4.33529C13.132 4.33547 15.6653 6.88618 15.6653 10.0257Z"></path></svg>
                    <span >DeepThink</span>
                  </div>
                  
                </div>
<!-- ===== Web Search Toggle (replace your old button with this) ===== -->
<label id="web-search-toggle" class="web-search-toggle" title="Enable web search" role="switch" aria-checked="false">
  <input id="web-search-checkbox" type="checkbox" aria-label="Enable web search" />
  <!-- Keep your SVG icon for visual match -->
  <span class="web-search-icon" aria-hidden="true">
    <svg width="20" height="24" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: currentColor;">
      <path fill-rule="evenodd" clip-rule="evenodd" d="M7.00003 0.150452C10.7832 0.150452 13.8496 3.21691 13.8496 7.00006C13.8496 10.7832 10.7832 13.8497 7.00003 13.8497C3.21688 13.8497 0.150421 10.7832 0.150421 7.00006C0.150421 3.21691 3.21688 0.150452 7.00003 0.150452ZM5.37796 7.59967C5.4267 9.0321 5.64754 10.2966 5.97366 11.2198C6.15996 11.7471 6.36946 12.1302 6.57327 12.3702C6.77751 12.6106 6.92343 12.6505 7.00003 12.6505C7.07663 12.6505 7.22255 12.6106 7.42679 12.3702C7.6306 12.1302 7.8401 11.7471 8.0264 11.2198C8.35252 10.2966 8.57336 9.0321 8.6221 7.59967H5.37796ZM1.38187 7.59967C1.61456 9.80498 3.11593 11.6305 5.14261 12.336C5.03268 12.1129 4.93227 11.8725 4.8428 11.6192C4.46342 10.5452 4.22775 9.13994 4.17874 7.59967H1.38187ZM9.82132 7.59967C9.77232 9.13994 9.53664 10.5452 9.15726 11.6192C9.06774 11.8726 8.96648 12.1127 8.85648 12.336C10.8836 11.6307 12.3855 9.8053 12.6182 7.59967H9.82132ZM7.00003 1.34967C6.92343 1.34967 6.77751 1.38955 6.57327 1.62994C6.36946 1.86994 6.15996 2.25297 5.97366 2.78033C5.64754 3.70357 5.4267 4.96802 5.37796 6.40045H8.6221C8.57336 4.96802 8.35252 3.70357 8.0264 2.78033C7.8401 2.25297 7.6306 1.86994 7.42679 1.62994C7.22255 1.38955 7.07663 1.34967 7.00003 1.34967ZM8.85648 1.66315C8.96663 1.88662 9.06763 2.12721 9.15726 2.38092C9.53664 3.45494 9.77232 4.86018 9.82132 6.40045H12.6182C12.3855 4.19471 10.8837 2.36834 8.85648 1.66315ZM5.14261 1.66315C3.11578 2.36856 1.61457 4.19503 1.38187 6.40045H4.17874C4.22775 4.86018 4.46342 3.45494 4.8428 2.38092C4.93237 2.12736 5.03253 1.88651 5.14261 1.66315Z" fill="currentColor"></path>
    </svg>
  </span>
  <span class="web-search-label">Search</span>
</label>

<!-- ===== Styles (paste into your stylesheet or <head>) ===== -->
<style>
  .web-search-toggle {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 10px;
    font-size: 0.9rem;        /* slightly smaller text */
    font-weight: 500;
    border-radius: 30px;
    border: 1px solid var(--web-search);
    cursor: pointer;
    user-select: none;
    font-size: 14px;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease, color .12s ease;
    background: transparent;
    color: var(--text-color, #111);
  }
  .web-search-toggle .web-search-icon { display: inline-flex; width:20px; height:20px; align-items:center; justify-content:center; }
  .web-search-toggle input { display: none; } /* hide native checkbox */
  /* Selected state */
  .web-search-toggle.selected {
    background: var(--accent-color, #6a0dad);
    color: #fff;
    box-shadow: 0 6px 20px rgba(0,0,0,0.12);
    transform: translateY(-1px);
    border: none;
    
    
  }
  /* .dark-mode.web-search-toggle.selected{
    background: black;
    color: #fff;
    border: 4px solid rgb(255, 255, 255);
  } */

  /* small hover polish */
  .web-search-toggle:hover { transform: translateY(-0.5px); }
  .web-search-label { line-height: 1; }
  @media (max-width: 600px) {
  .web-search-toggle {
    font-size: 12px;
    padding: 5px 10px;
    gap: 6px;
  }
  .web-search-toggle .web-search-icon {
    width: 18px;
    height: 18px;
  }
}
</style>

<!-- ===== Script (paste near end of body, after other scripts for safety) ===== -->
<script>
  (function () {
    // Robust initialization after DOM ready
    function initToggle() {
      // 1) replace old button if present (removes any old click handler attached by app.js)
      const oldBtn = document.getElementById("web-search-btn");
      if (oldBtn) {
        // create the new label element from the existing markup (we already placed markup above),
        // but if user didn't paste the label HTML, fallback to creating programmatically:
        const existingToggle = document.getElementById("web-search-toggle");
        if (existingToggle) {
          oldBtn.replaceWith(existingToggle);
        } else {
          // nothing to replace with; bail (user should include the HTML snippet)
          console.warn("web-search-toggle markup not found — please paste the provided label HTML into your page.");
        }
      }

      const label = document.getElementById("web-search-toggle");
      const checkbox = document.getElementById("web-search-checkbox");

      if (!label || !checkbox) {
        console.warn("Web search toggle elements not found.");
        return;
      }

      // 2) restore state from localStorage
      const saved = localStorage.getItem("vexara_web_search_enabled");
      const initiallyEnabled = saved === "1";
      window.isWebSearchEnabled = !!initiallyEnabled;
      checkbox.checked = window.isWebSearchEnabled;
      label.classList.toggle("selected", window.isWebSearchEnabled);
      label.setAttribute("aria-checked", window.isWebSearchEnabled ? "true" : "false");

      // 3) change handler (update UI + persist)
      checkbox.addEventListener("change", (e) => {
        const enabled = !!checkbox.checked;
        window.isWebSearchEnabled = enabled;
        localStorage.setItem("vexara_web_search_enabled", enabled ? "1" : "0");
        label.classList.toggle("selected", enabled);
        label.setAttribute("aria-checked", enabled ? "true" : "false");
      });

      // 4) clicking the label toggles the checkbox but prevent accidental form submits / bubbling
      label.addEventListener("click", function (e) {
        // prevent click from submitting forms or bubbling; checkbox will toggle as normal
        e.preventDefault();
        e.stopPropagation();
        checkbox.checked = !checkbox.checked;
        checkbox.dispatchEvent(new Event("change", { bubbles: true }));
      });

      // 5) Monkeypatch askAI so existing calls that don't pass performSearch use the checkbox state
      //    This is safe: if a caller passes true/false explicitly, it will be honored.
      function wrapAskAIWhenReady() {
        if (window.askAI && !window._askAIWrapped) {
          const orig = window.askAI;
          window.askAI = async function (instruction, modelChoice, performSearch) {
            if (typeof performSearch === "undefined" || performSearch === null) {
              performSearch = !!window.isWebSearchEnabled;
            }
            return await orig.call(this, instruction, modelChoice, performSearch);
          };
          window._askAIWrapped = true;
          console.log("askAI wrapped to use web-search toggle when performSearch is omitted.");
        } else if (!window.askAI) {
          // If askAI not defined yet, try a few times (this won't run forever)
          let tries = 0;
          const t = setInterval(() => {
            tries++;
            if (window.askAI) {
              clearInterval(t);
              wrapAskAIWhenReady();
            } else if (tries > 30) {
              clearInterval(t);
              console.warn("askAI not found after waiting — web-search toggle wrapper not applied.");
            }
          }, 100); // try for ~3s
        }
      }
      wrapAskAIWhenReady();

      // 6) Expose a global helper (optional) in case other UI wants to show the state
      window.setWebSearchUI = function (bool) {
        checkbox.checked = !!bool;
        checkbox.dispatchEvent(new Event("change", { bubbles: true }));
      };
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initToggle);
    } else {
      initToggle();
    }
  })();
</script>

              </div>

              <div class="input-icons-right">
                <button style="margin-right: 10px;"
                  type="button"
                  id="voice-talk-btn"
                  class="input-icon-btn"
                  title="Toggle Voice Talk"
                  aria-label="Toggle Voice Talk"
                >
                  <svg
                    width="40"
                    height="40"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    xmlns="http://www.w3.org/2000/svg"
                    class="icon"
                  >
                    <path
                      d="M7.33496 15.5V4.5C7.33496 4.13275 7.63275 3.83499 8 3.83496C8.36727 3.83496 8.66504 4.13273 8.66504 4.5V15.5C8.66504 15.8673 8.36727 16.165 8 16.165C7.63275 16.165 7.33496 15.8673 7.33496 15.5ZM11.335 13.1309V7.20801C11.335 6.84075 11.6327 6.54298 12 6.54297C12.3673 6.54297 12.665 6.84074 12.665 7.20801V13.1309C12.665 13.4981 12.3672 13.7959 12 13.7959C11.6328 13.7959 11.335 13.4981 11.335 13.1309ZM3.33496 11.3535V8.81543C3.33496 8.44816 3.63273 8.15039 4 8.15039C4.36727 8.15039 4.66504 8.44816 4.66504 8.81543V11.3535C4.66504 11.7208 4.36727 12.0186 4 12.0186C3.63273 12.0186 3.33496 11.7208 3.33496 11.3535ZM15.335 11.3535V8.81543C15.335 8.44816 15.6327 8.15039 16 8.15039C16.3673 8.15039 16.665 8.44816 16.665 8.81543V11.3535C16.665 11.7208 16.3673 12.0186 16 12.0186C15.6327 12.0186 15.335 11.7208 15.335 11.3535Z"
                    ></path>
                  </svg>
                </button>

                <button
                  type="submit"
                  class="submit-btn"
                  id="send-btn"
                  title="Send Message"
                  aria-label="Send Message"
                >
                  <i class="fa-solid fa-arrow-up"></i>
                </button>

                <button
                  type="button"
                  class="stop-btn"
                  id="stop-btn"
                  title="Stop Response"
                  aria-label="Stop AI Response"
                >
                  <i class="fas fa-stop" aria-hidden="true"></i>
                </button>
              </div>
            </div>

            <!-- Voice indicator area -->
            <div
              id="voice-indicator-area"
              class="voice-indicator-area"
              aria-live="polite"
              aria-atomic="true"
            >
              <div class="typing-indicator">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
              </div>
              <span id="voice-status-text"></span>
            </div>
          </div>
          <div
            style="
              display: flex;
              justify-content: center;
              width: 100%;
              position: relative;
              top: 5px;
            "
          >
            <p
              style="
                font-size: 0.6rem;
                color: var(--text-color);
                text-align: center;
                margin: 0;
                opacity: 0.9;
              "
            >
              Top priority to privacy, feel free to chat
            </p>
          </div>
        </form>
      </div>

      <!-- Loading Indicator -->
      <div
        class="loader"
        id="loader"
        aria-live="polite"
        aria-atomic="true"
        style="display: none"
      >
        <div class="typing-indicator">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
        </div>
      </div>
    </div>

    <!-- NEW: Voice Mode Full-Screen Overlay -->
    <div
      id="voice-mode-overlay"
      role="dialog"
      aria-modal="true"
      aria-label="Voice Interaction Mode"
    >
      <div class="status-text">Standard voice</div>
      <canvas
        id="voice-circle-canvas"
        role="img"
        aria-label="Voice Activity Visualizer"
      ></canvas>
      <div class="control-buttons">
        <button
          id="mic-control-btn"
          class="control-button"
          aria-label="Toggle Microphone"
        >
          <i class="fas fa-microphone" aria-hidden="true"></i>
        </button>
        <button
          id="screen-share-btn"
          class="control-button"
          title="Toggle Screen Share"
          aria-label="Toggle Screen Share"
        >
          <i class="fas fa-desktop" aria-hidden="true"></i>
        </button>
        <button
          id="close-voice-mode-btn"
          class="control-button"
          aria-label="Close Voice Mode"
        >
          <i class="fas fa-times" aria-hidden="true"></i>
        </button>
      </div>
    </div>

    <!-- NEW: Screen Share Preview Container -->
    <div
      id="screen-share-preview-container"
      role="dialog"
      aria-modal="true"
      aria-label="Screen Share Preview"
    >
      <video
        id="screen-share-preview-video"
        autoplay
        aria-label="Screen Share Video Feed"
      ></video>
    </div>

    <!-- Confirmation Modal for Clear All Chats -->
    <div
      id="confirmModal"
      class="modal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="modalTitle"
      aria-describedby="modalDescription"
    >
      <div class="modal-content">
        <h3 id="modalTitle">Clear All Chats?</h3>
        <p id="modalDescription">
          Are you sure you want to clear all chat history? This action cannot be
          undone.
        </p>
        <div class="modal-buttons">
          <button
            class="modal-btn cancel"
            onclick="hideModal()"
            aria-label="Cancel"
          >
            Cancel
          </button>
          <button
            class="modal-btn confirm"
            id="confirmClearBtn"
            aria-label="Confirm Clear All"
          >
            Clear All
          </button>
        </div>
      </div>
    </div>

    <!-- NEW: Code Update Modal -->
    <div
      id="codeUpdateModal"
      class="modal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="codeUpdateModalTitle"
    >
      <div class="modal-content">
        <h3 id="codeUpdateModalTitle">Update Code File</h3>
        <p>
          Paste the updated code below. Select the file to update (e.g.,
          `index.html` or `test.py`).
        </p>
        <select id="fileToUpdateSelect" aria-label="Select file to update">
          <option value="index.html">index.html (Frontend HTML/JS)</option>
          <option value="test.py">test.py (Backend Python)</option>
          <option value="script.py">
            script.py (Backend Python - if applicable)
          </option>
        </select>
        <textarea
          id="codeUpdateTextarea"
          placeholder="Paste your updated code here..."
          aria-label="Code to update"
        ></textarea>
        <div class="modal-buttons">
          <button
            class="modal-btn cancel"
            onclick="document.getElementById('codeUpdateModal').style.display='none';"
            aria-label="Cancel"
          >
            Cancel
          </button>
          <button
            class="modal-btn confirm"
            id="applyCodeUpdateBtn"
            aria-label="Apply Code Update"
          >
            Apply Update
          </button>
        </div>
      </div>
    </div>

    <!-- Camera Options (for mobile file upload) -->
    <div
      class="camera-options"
      role="dialog"
      aria-modal="true"
      aria-label="Choose Image Source"
    >
      <div
        class="camera-option"
        id="take-photo"
        tabindex="0"
        role="button"
        aria-label="Take Photo"
      >
        <i class="fas fa-camera" aria-hidden="true"></i>
        <span>Take Photo</span>
        <!-- Hidden input directly inside the clickable area -->
        <input
          type="file"
          id="take-photo-input"
          name="image"
          accept="image/*"
          capture="environment"
          style="
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
          "
        />
      </div>
      <div
        class="camera-option"
        id="upload-photo"
        tabindex="0"
        role="button"
        aria-label="Choose from Gallery"
      >
        <i class="fas fa-images" aria-hidden="true"></i>
        <span>Choose from Gallery</span>
        <!-- Hidden input directly inside the clickable area -->
        <input
          type="file"
          id="upload-photo-input"
          name="image"
          accept="image/*"
          style="
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 1;
          "
        />
      </div>
      <div
        class="camera-option cancel"
        id="cancel-camera"
        tabindex="0"
        role="button"
        aria-label="Cancel"
      >
        <i class="fas fa-times" aria-hidden="true"></i>
        <span>Cancel</span>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.0/marked.min.js"></script>
    <script src="/static/app.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const inputContainer = document.querySelector(".input-container");
        const textInput = document.getElementById("text-input");
        const sendBtn = document.getElementById("send-btn");
        const stopBtn = document.getElementById("stop-btn");
        const fileInput = document.getElementById("file-input");
        const attachBtn = document.getElementById("attach-file-btn");

        // Focus textarea when clicking anywhere in the container
        inputContainer.addEventListener("click", function (e) {
          if (
            !e.target.closest(".input-icon-btn") &&
            !e.target.closest(".submit-btn") &&
            !e.target.closest(".stop-btn") &&
            e.target !== fileInput
          ) {
            textInput.focus();
          }
        });

        // Auto-resize textarea
        textInput.addEventListener("input", function () {
          this.style.height = "auto";
          this.style.height = this.scrollHeight + "px";
        });

        // File input
        attachBtn.addEventListener("click", function () {
          fileInput.click();
        });

        fileInput.addEventListener("change", function () {
          if (this.files && this.files[0]) {
            console.log("File selected:", this.files[0].name);
          }
        });

        // ✅ Show and hide stop button explicitly
        function showStopButton() {
          stopBtn.style.display = "inline-flex";
          sendBtn.style.display = "none";
        }

        function hideStopButton() {
          stopBtn.style.display = "none";
          sendBtn.style.display = "inline-flex";
        }

        // When send is clicked
        sendBtn.addEventListener("click", function () {
          if (textInput.value.trim() !== "") {
            showStopButton();

            // Simulate AI response completion
            setTimeout(function () {
              hideStopButton();
            }, 3000);
          }
        });

        // Stop button click
        stopBtn.addEventListener("click", function () {
          hideStopButton();
          console.log("AI response stopped");
        });

        // Initially hide stop button
        hideStopButton();
      });
    </script>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const inputContainer = document.querySelector(".input-container");
        const textInput = document.getElementById("text-input");
        const sendBtn = document.getElementById("send-btn");
        const stopBtn = document.getElementById("stop-btn");
        const fileInput = document.getElementById("file-input");
        const attachBtn = document.getElementById("attach-file-btn");

        // Focus textarea when clicking anywhere in the container
        inputContainer.addEventListener("click", function (e) {
          // Don't focus if clicking on a button or file input
          if (
            !e.target.closest(".input-icon-btn") &&
            !e.target.closest(".submit-btn") &&
            !e.target.closest(".stop-btn") &&
            e.target !== fileInput
          ) {
            textInput.focus();
          }
        });

        // Auto-resize textarea as user types
        textInput.addEventListener("input", function () {
          this.style.height = "auto";
          this.style.height = this.scrollHeight + "px";
        });

        // File input functionality
        attachBtn.addEventListener("click", function () {
          fileInput.click();
        });

        fileInput.addEventListener("change", function (e) {
          if (this.files && this.files[0]) {
            // Handle file selection here
            console.log("File selected:", this.files[0].name);
            // You can show a preview or process the file
          }
        });

        // Function to show stop button (when AI is responding)
        function showStopButton() {
          stopBtn.style.display = "inline-flex";
          sendBtn.style.display = "none";
        }

        // Function to hide stop button (when AI is done responding)
        function hideStopButton() {
          stopBtn.style.display = "none";
          sendBtn.style.display = "inline-flex";
        }

        // Example usage - call these functions when AI starts/stops responding
        sendBtn.addEventListener("click", function () {
          if (textInput.value.trim() !== "") {
            showStopButton();

            // Simulate AI response (remove this in your actual implementation)
            setTimeout(function () {
              hideStopButton();
            }, 3000);
          }
        });

        // Stop button functionality
        stopBtn.addEventListener("click", function () {
          // Stop AI response logic here
          hideStopButton();
          console.log("AI response stopped");
        });

        // ✅ FIX: Hide the stop button when the page loads
        hideStopButton();
      });
    </script>
    <script>// Function to show loader at the response position
function showLoader() {
  const loader = document.getElementById('loader');
  loader.style.display = 'block';
  // Scroll to the loader position
  loader.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

// Function to hide loader
function hideLoader() {
  document.getElementById('loader').style.display = 'none';
}</script>
          <script>
            const deepthinkToggle = document.getElementById("deepthink-toggle");
            const generalInput = document.getElementById("modelGeneral");
          
            deepthinkToggle.addEventListener("click", () => {
              const isActive = deepthinkToggle.getAttribute("data-active") === "true";
          
              if (isActive) {
                // Switch OFF DeepThink -> select general input
                deepthinkToggle.setAttribute("data-active", "false");
                generalInput.checked = true;
                console.log("🔄 Switched back to General Mode");
              } else {
                // Switch ON DeepThink -> create & check a hidden input dynamically
                deepthinkToggle.setAttribute("data-active", "true");
          
                // remove old hidden deepthink if exists
                let deepthinkInput = document.getElementById("modelDeepThink");
                if (!deepthinkInput) {
                  deepthinkInput = document.createElement("input");
                  deepthinkInput.type = "radio";
                  deepthinkInput.name = "modelChoice";
                  deepthinkInput.value = "deep_think";
                  deepthinkInput.id = "modelDeepThink";
                  deepthinkInput.style.display = "none";
                  deepthinkToggle.parentElement.appendChild(deepthinkInput);
                }
                deepthinkInput.checked = true;
          
                console.log("🧠 DeepThink Mode Activated");
              }
            });
          </script>
          <script>
            document.addEventListener("DOMContentLoaded", () => {
              const webSearchBtn = document.getElementById("web-search-btn");
              const multiActionForm = document.getElementById("multi-action-form");
              let isWebSearchEnabled = false;
          
              // ✅ Toggle Web Search Mode
              webSearchBtn.addEventListener("click", () => {
                isWebSearchEnabled = !isWebSearchEnabled;
                webSearchBtn.classList.toggle("selected", isWebSearchEnabled);
              });
          
              // ✅ Intercept form submit to include web search flag
              multiActionForm.addEventListener("submit", async (e) => {
                e.preventDefault();
          
                const textInput = document.getElementById("text-input");
                const userText = textInput.value.trim();
                if (!userText) return;
          
                // Detect selected model choice
                const selectedModelRadio = document.querySelector(
                  "input[name='modelChoice']:checked"
                );
                const modelChoice = selectedModelRadio ? selectedModelRadio.value : "general";
          
                // Show user message
                addMessage(userText, "user", null, new Date());
          
                // ✅ Perform AI request with web search if enabled
                if (isWebSearchEnabled) {
                  await askAI(userText, modelChoice, true);
                } else {
                  await askAI(userText, modelChoice, false);
                }
              });
            });
          </script>
          
          <style>
            /* ✅ Web Search Button Active State */
            #web-search-btn.selected {
              background: var(--accent-color);
              color: white;
              border-radius: 10px;
              box-shadow: 0 0 10px var(--accent-color);
            }
            /* Thinking Process Styles */
            
.thinking {
  font-size: 0.8rem;
  color: rgba(128,128,128,0.8); /* greyed out */
  margin-top: 6px;
  padding-left: 8px;
  border-left: 2px dashed #ccc;
  display: none; /* hidden by default */
}

.thinking.show {
  display: block;
}

.toggle-thinking {
  font-size: 0.75rem;
  background: none;
  border: none;
  color: #888;
  cursor: pointer;
  margin-top: 4px;
}
</style>

<script>
function addBotMessage(content, thinking = null) {
  const messageDiv = document.createElement("div");
  messageDiv.classList.add("bot-message");

  // Main AI answer
  const answerDiv = document.createElement("div");
  answerDiv.classList.add("answer");
  answerDiv.innerHTML = content;
  messageDiv.appendChild(answerDiv);

  // Optional reasoning trace
  if (thinking) {
    const thinkingDiv = document.createElement("div");
    thinkingDiv.classList.add("thinking");
    thinkingDiv.innerHTML = thinking;

    const toggleBtn = document.createElement("button");
    toggleBtn.classList.add("toggle-thinking");
    toggleBtn.textContent = "Show Thinking";
    toggleBtn.onclick = function () {
      thinkingDiv.classList.toggle("show");
      toggleBtn.textContent = thinkingDiv.classList.contains("show")
        ? "Hide Thinking"
        : "Show Thinking";
    };

    messageDiv.appendChild(toggleBtn);
    messageDiv.appendChild(thinkingDiv);
  }

  document.querySelector("#chat-container").appendChild(messageDiv);
  document.querySelector("#chat-container").scrollTop =
    document.querySelector("#chat-container").scrollHeight;
}
</script>
<script>// Global variables for chat management
let currentChatId = null;
let sidebarHidden = false; // Tracks if sidebar is manually collapsed on desktop
let isFullScreen = false; // Tracks if full screen chat mode is active
let abortController = null; // Global AbortController for stopping AI responses

// Voice Talk Globals
let recognition;
let synth = window.speechSynthesis;
let isVoiceTalkActive = false; // Controls the full-screen voice overlay
let isListening = false; // Controls SpeechRecognition state
let isSpeaking = false; // Controls SpeechSynthesis state
let pendingBotSpeechText = ""; // Global to hold the actual text that will be displayed after speaking
let speechQueue = []; // Queue for streaming speech synthesis
let isProcessingSpeechQueue = false; // Flag to manage speech queue processing
let selectedVoice = null; // Stores the selected voice for AI speech

// Web Audio API for visualizer
let audioContext;
let analyser;
let microphoneStream;
let animationFrameId;
let canvas, canvasCtx;
let bufferLength;
let dataArray;
// let aiVoiceSource; // Not directly used as SpeechSynthesis doesn't expose an audio source node

// Screen Share Globals
let screenShareStream = null;
let screenShareInterval = null;
let isScreenSharing = false;
const screenCaptureCanvas = document.createElement("canvas"); // Off-screen canvas
const screenCaptureCtx = screenCaptureCanvas.getContext("2d");
const screenShareVideoElement = document.getElementById(
  "screen-share-preview-video"
);
const screenSharePreviewContainer = document.getElementById(
  "screen-share-preview-container"
);

// Helper Functions
function scrollToBottom() {
  const chatbox = document.getElementById("chatbox");
  chatbox.scrollTop = chatbox.scrollHeight;
}

// Function to escape HTML entities for display within a text area or code block
function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// Helper to safely escape code inside template literals for onclick attribute
function escapeForTemplateLiteral(str) {
  return str.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
}

// Custom Marked.js Renderer for Code Blocks
const renderer = new marked.Renderer();
renderer.code = function (code, lang) {
  const language = lang || "plaintext";

  // Determine file type based on language for update button
  let fileType = "txt";
  if (["html", "javascript", "css"].includes(language.toLowerCase())) {
    fileType = "index.html";
  } else if (language.toLowerCase() === "python") {
    fileType = "test.py";
  }

  // Use highlight.js if language is supported; else escape raw code
  let highlighted = "";
  if (hljs.getLanguage(language)) {
    highlighted = hljs.highlight(code, { language }).value;
  } else {
    highlighted = escapeHtml(code);
  }

  return `
<div class="code-block">
<div class="code-header">
<span class="code-language">${language.toUpperCase()}</span>
<div>
  <button class="copy-btn" onclick="copyToClipboard(this)" aria-label="Copy code to clipboard">
      <i class="far fa-copy" aria-hidden="true"></i> Copy
  </button>
  <button class="update-code-btn" onclick="openCodeUpdateModal(\`${escapeForTemplateLiteral(
    code
  )}\`, '${fileType}')" aria-label="Update code file">
      <i class="fas fa-code" aria-hidden="true"></i> Update
  </button>
</div>
</div>
<pre><code class="language-${language}">${highlighted}</code></pre>
</div>
`;
};

// Override paragraph rendering to add default margins (optional)
renderer.paragraph = function (text) {
  return `<p>${text}</p>`;
};

// Marked.js options with highlight.js integration
marked.setOptions({
  breaks: true, // GitHub-flavored line breaks
  highlight: function (code, lang) {
    if (hljs.getLanguage(lang)) {
      return hljs.highlight(code, { language: lang }).value;
    }
    return escapeHtml(code);
  },
  renderer: renderer,
});

// Function to copy code to clipboard
window.copyToClipboard = function (button) {
  const codeBlock = button.closest(".code-block").querySelector("code");
  if (codeBlock) {
    const textToCopy = codeBlock.textContent || codeBlock.innerText;

    // Create a temporary textarea element to hold the text
    const tempTextArea = document.createElement("textarea");
    tempTextArea.value = textToCopy;
    tempTextArea.style.position = "fixed"; // Prevent scrolling to bottom of page
    tempTextArea.style.left = "-9999px"; // Move off-screen
    tempTextArea.style.top = "0";
    document.body.appendChild(tempTextArea);

    // Select the text in the textarea
    tempTextArea.focus();
    tempTextArea.select();

    try {
      // Execute the copy command
      const successful = document.execCommand("copy");
      if (successful) {
        button.innerHTML =
          '<i class="fas fa-check" aria-hidden="true"></i> Copied!';
        setTimeout(() => {
          button.innerHTML =
            '<i class="far fa-copy" aria-hidden="true"></i> Copy';
        }, 2000);
      } else {
        // Fallback for modern browsers if execCommand fails (e.g., due to restrictions)
        // This part might still fail in strict iframe environments, but it's the standard fallback.
        navigator.clipboard
          .writeText(textToCopy)
          .then(() => {
            button.innerHTML =
              '<i class="fas fa-check" aria-hidden="true"></i> Copied!';
            setTimeout(() => {
              button.innerHTML =
                '<i class="far fa-copy" aria-hidden="true"></i> Copy';
            }, 2000);
          })
          .catch((err) => {
            console.error(
              "Failed to copy text using navigator.clipboard:",
              err
            );
            // Provide user feedback if both methods fail
            button.innerHTML =
              '<i class="fas fa-times" aria-hidden="true"></i> Failed';
            setTimeout(() => {
              button.innerHTML =
                '<i class="far fa-copy" aria-hidden="true"></i> Copy';
            }, 2000);
          });
      }
    } catch (err) {
      console.error("Failed to copy text using document.execCommand:", err);
      // Fallback to navigator.clipboard if execCommand throws an error
      navigator.clipboard
        .writeText(textToCopy)
        .then(() => {
          button.innerHTML =
            '<i class="fas fa-check" aria-hidden="true"></i> Copied!';
          setTimeout(() => {
            button.innerHTML =
              '<i class="far fa-copy" aria-hidden="true"></i> Copy';
          }, 2000);
        })
        .catch((err) => {
          console.error(
            "Failed to copy text using navigator.clipboard (fallback):",
            err
          );
          button.innerHTML =
            '<i class="fas fa-times" aria-hidden="true"></i> Failed';
          setTimeout(() => {
            button.innerHTML =
              '<i class="far fa-copy" aria-hidden="true"></i> Copy';
          }, 2000);
        });
    } finally {
      // Clean up the temporary textarea
      document.body.removeChild(tempTextArea);
    }
  }
};

// Function to add a new message to the chatbox
function addMessage(
  text,
  type = "bot",
  optionalContent = null,
  timestamp = new Date()
) {
  const chatbox = document.getElementById("chatbox");
  const newChatPlaceholder = document.getElementById("new-chat-placeholder");
  if (newChatPlaceholder) {
    newChatPlaceholder.remove(); // Remove placeholder once messages start
  }

  const msg = document.createElement("div");
  msg.className = `chat-message ${type}-message pulse`; // Add pulse animation class

  const header = document.createElement("div");
  header.className = "message-header";
  header.innerHTML = type === "user" ? "You" : "";

  const timestampSpan = document.createElement("span");
  timestampSpan.className = "message-timestamp";
  timestampSpan.textContent = timestamp.toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit",
  });
  // header.appendChild(timestampSpan);
  // msg.appendChild(header);

  const content = document.createElement("div");
  content.className = "message-content";
  // Warn if text content is unexpectedly empty for user messages
  if (type === "user" && !text.trim()) {
    console.warn(
      "User message text is empty. This might indicate an issue with backend message storage."
    );
    content.innerHTML = "*(No text provided)*"; // Placeholder for empty text
  } else {
    content.innerHTML = marked.parse(text); // Parse markdown content
  }
  msg.appendChild(content);

  // Append optional content (e.g., uploaded image or generated images)
  if (optionalContent) {
    if (optionalContent instanceof HTMLElement) {
      msg.appendChild(optionalContent);
    } else if (Array.isArray(optionalContent)) {
      const imageContainer = document.createElement("div");
      imageContainer.className = "message-images-container";
      optionalContent.forEach((imageUrl) => {
        const imgElement = document.createElement("img");
        imgElement.src = imageUrl;
        imgElement.alt = "Generated Image";
        imageContainer.appendChild(imgElement);
      });
      msg.appendChild(imageContainer);
    }
  }

  chatbox.appendChild(msg);
  scrollToBottom();

  // Highlight code blocks after adding message
  document.querySelectorAll(".chat-message code").forEach((block) => {
    try {
      hljs.highlightElement(block);
    } catch (e) {
      console.warn("Highlight.js failed on block:", block, e);
      block.style.color = "var(--code-text-color)";
    }
  });
}

// Function to simulate typing effect for bot messages
// This function is now responsible for creating the initial message container
// and updating its content as chunks arrive.
let currentBotMessageElement = null; // Reference to the current bot message being typed
let currentBotMessageContentDiv = null; // Reference to the content div within that message
let currentBotMessageFullText = ""; // Accumulates the full text for saving/actions

// Global/module-level declaration for sentence detector
const sentenceRegex = /[^.!?]+[.!?]+/g; // Moved to global scope

function createStreamingBotMessage(timestamp = new Date()) {
  const chatbox = document.getElementById("chatbox");
  const newChatPlaceholder = document.getElementById("new-chat-placeholder");
  if (newChatPlaceholder) {
    newChatPlaceholder.remove(); // Remove placeholder once messages start
  }

  const msg = document.createElement("div");
  msg.className = `chat-message bot-message`; // No pulse on typing init

  const header = document.createElement("div");
  header.className = "message-header";
  // header.innerHTML = 'Vexara';

  const timestampSpan = document.createElement("span");
  timestampSpan.className = "message-timestamp";
  timestampSpan.textContent = timestamp.toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit",
  });
  header.appendChild(timestampSpan);
  msg.appendChild(header);

  currentBotMessageContentDiv = document.createElement("div");
  currentBotMessageContentDiv.className = "message-content";
  msg.appendChild(currentBotMessageContentDiv);

  chatbox.appendChild(msg);
  scrollToBottom();

  currentBotMessageElement = msg; // Store reference to the new message element
  currentBotMessageFullText = ""; // Reset full text accumulator
  pendingBotSpeechText = ""; // Ensure pending speech text is cleared for new message
  sentenceRegex.lastIndex = 0; // Reset regex state for new message
}

async function appendToStreamingBotMessage(chunk) {
  if (!currentBotMessageContentDiv) {
    console.error("No active bot message element to append to.");
    return;
  }

  currentBotMessageFullText += chunk;

  // If voice talk is active, try to speak chunks as sentences
  if (isVoiceTalkActive) {
    pendingBotSpeechText += chunk;
    let lastSpokenIndex = 0; // Track the end index of the last spoken sentence

    // Reset lastIndex for each new processing cycle of pendingBotSpeechText
    // This is crucial because pendingBotSpeechText is modified.
    sentenceRegex.lastIndex = 0;
    let match;

    // Loop to find all complete sentences in the current pendingBotSpeechText
    while ((match = sentenceRegex.exec(pendingBotSpeechText)) !== null) {
      const sentence = match[0].trim();
      if (sentence) {
        speakText(sentence);
        lastSpokenIndex = sentenceRegex.lastIndex; // Store the index up to which we've spoken
      }
    }

    // Remove the spoken sentences from the beginning of pendingBotSpeechText
    if (lastSpokenIndex > 0) {
      pendingBotSpeechText = pendingBotSpeechText.substring(lastSpokenIndex);
    }
    // No need to reset sentenceRegex.lastIndex here, it will be reset at the start of the next call.
  }
  // Always update innerHTML with parsed Markdown for immediate visual feedback
  currentBotMessageContentDiv.innerHTML = marked.parse(
    currentBotMessageFullText
  );

  currentBotMessageContentDiv.querySelectorAll("pre code").forEach((block) => {
    try {
      hljs.highlightElement(block);
    } catch (e) {
      console.warn("Highlight.js failed on block during streaming:", block, e);
      block.style.color = "var(--code-text-color)";
    }
  });

  scrollToBottom();
}

async function finalizeStreamingBotMessage(image_urls = []) {
  if (!currentBotMessageElement) {
    console.error("No active bot message element to finalize.");
    return;
  }

  // Speak any remaining pending text if voice talk is active
  if (isVoiceTalkActive && pendingBotSpeechText) {
    await new Promise((resolve) => {
      const finalUtterance = new SpeechSynthesisUtterance(pendingBotSpeechText);
      finalUtterance.lang = "en-US";
      finalUtterance.pitch = 1.0; // Default pitch
      finalUtterance.rate = 1.0; // Default rate
      finalUtterance.voice = selectedVoice; // Apply selected voice
      finalUtterance.onend = resolve;
      finalUtterance.onerror = resolve; // Resolve even on error to finalize message
      synth.speak(finalUtterance);
    });
  }

  // Ensure the content is displayed if it wasn't during streaming (e.g., voice mode was active)
  // This will re-render the entire message with full Markdown parsing and highlighting.
  if (currentBotMessageContentDiv && currentBotMessageFullText) {
    // Check if full text exists
    currentBotMessageContentDiv.innerHTML = marked.parse(
      currentBotMessageFullText
    );
    currentBotMessageContentDiv
      .querySelectorAll("pre code")
      .forEach((block) => {
        try {
          hljs.highlightElement(block);
        } catch (e) {
          console.warn(
            "Highlight.js failed on block during streaming (finalize):",
            block,
            e
          );
          block.style.color = "var(--code-text-color)";
        }
      });
  }

  // Append images
  if (image_urls && image_urls.length > 0) {
    const imageContainer = document.createElement("div");
    imageContainer.className = "message-images-container";
    image_urls.forEach((imageUrl) => {
      const imgElement = document.createElement("img");
      imgElement.src = imageUrl;
      imgElement.alt = "Generated Image";
      imageContainer.appendChild(imgElement);
    });
    currentBotMessageElement.appendChild(imageContainer);
    scrollToBottom();
  }

  // Add action buttons
  if (currentBotMessageFullText.length > 100) {
    const messageActionsDiv = document.createElement("div");
    messageActionsDiv.className = "message-actions";

    const summarizeButton = document.createElement("button");
    summarizeButton.className = "message-action-btn";
    summarizeButton.innerHTML =
      '<i class="fas fa-sparkle" aria-hidden="true"></i> Summarize';
    summarizeButton.onclick = async () => {
      summarizeButton.disabled = true;
      summarizeButton.innerHTML =
        '<i class="fas fa-hourglass-half" aria-hidden="true"></i> Summarizing...';
      const summary = await summarizeText(currentBotMessageFullText);
      if (summary) {
        addMessage(`**Summary:** ${summary}`, "bot", null, new Date());
      }
      summarizeButton.disabled = false;
      summarizeButton.innerHTML =
        '<i class="fas fa-sparkle" aria-hidden="true"></i> Summarize';
    };
    messageActionsDiv.appendChild(summarizeButton);
    currentBotMessageElement.appendChild(messageActionsDiv);
  }

  // Clear references
  currentBotMessageElement = null;
  currentBotMessageContentDiv = null;
  currentBotMessageFullText = "";
  pendingBotSpeechText = ""; // Ensure this is cleared here too
  sentenceRegex.lastIndex = 0; // Ensure regex state is reset on finalization
  scrollToBottom(); // Final scroll to ensure everything is visible

  // If voice mode is active, restart listening after AI finishes speaking
  if (isVoiceTalkActive) {
    startListening();
  }
}

// AI Function Calls (stubs, assume backend handles actual API calls)
async function askAI(instruction, modelChoice, performSearch = false) {
  // Added performSearch parameter
  const textInput = document.getElementById("text-input");
  const loader = document.getElementById("loader");

  // Show loader BEFORE creating the streaming message
  loader.style.display = "block";
  showStopButton(); // Show stop button, hide send button
  stopSpeaking(); // Stop AI speech if any

  // Initialize AbortController for this request
  abortController = new AbortController();
  const signal = abortController.signal;

  try {
    const formData = new FormData();
    formData.append("instruction", instruction);
    formData.append("chat_id", currentChatId);
    formData.append("model_choice", modelChoice); // Append model choice
    formData.append("web_search", performSearch); // Pass the web_search flag

    const response = await fetch(`${window.location.origin}/ask`, {
      method: "POST",
      body: formData,
      signal: signal, // Pass the abort signal to the fetch request
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Server error: ${response.status} ${response.statusText} - ${errorText}`
      );
    }

    // Hide loader once the actual streaming starts
    loader.style.display = "none";

    // Create the initial message container for streaming
    createStreamingBotMessage(new Date());

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let done = false;

    while (!done) {
      const { value, done: readerDone } = await reader.read();
      done = readerDone;
      const chunk = decoder.decode(value, { stream: true });
      if (chunk) {
        await appendToStreamingBotMessage(chunk);
      }
    }

    // Finalize the streaming message after stream finishes
    finalizeStreamingBotMessage();
  } catch (error) {
    loader.style.display = "none"; // Hide loader on error
    if (error.name === "AbortError") {
      console.log("Fetch aborted by user.");
      if (currentBotMessageContentDiv) {
        currentBotMessageContentDiv.innerHTML += `<p>*(Response stopped by user)*</p>`;
      } else {
        addMessage(`Response stopped by user.`, "bot", null, new Date());
      }
    } else {
      console.error("Error asking AI:", error);
      // If an error occurs, ensure the message is still added or updated
      if (currentBotMessageContentDiv) {
        currentBotMessageContentDiv.innerHTML += `<p>Error: ${error.message}</p>`;
      } else {
        addMessage(
          `Sorry, there was an error processing your request: ${error.message}. Please try again.`,
          "bot",
          null,
          new Date()
        );
      }
    }
    finalizeStreamingBotMessage(); // Attempt to finalize even on error
  } finally {
    textInput.value = "";
    textInput.style.height = "auto"; // Reset textarea height
    textInput.focus();
    showSendButton(); // Show send button, hide stop button
    abortController = null; // Clear the controller
  }
}

async function generateImage(prompt) {
  const textInput = document.getElementById("text-input");
  const loader = document.getElementById("loader");
  loader.style.display = "block";
  showStopButton(); // Show stop button
  stopSpeaking(); // Stop AI speech if any

  abortController = new AbortController();
  const signal = abortController.signal;

  try {
    const formData = new FormData();
    formData.append("instruction", prompt);
    formData.append("chat_id", currentChatId);

    const response = await fetch(`${window.location.origin}/generate_image`, {
      method: "POST",
      body: formData,
      signal: signal, // Pass the abort signal
    });
    const data = await response.json();

    loader.style.display = "none";

    if (data.image_urls && data.image_urls.length > 0) {
      addMessage(data.response, "bot", data.image_urls, new Date());
      if (isVoiceTalkActive && data.response) speakText(data.response);
    } else {
      addMessage(data.response, "bot", null, new Date());
      if (isVoiceTalkActive && data.response) speakText(data.response);
    }
  } catch (error) {
    loader.style.display = "none"; // Hide loader on error
    if (error.name === "AbortError") {
      console.log("Image generation aborted by user.");
      addMessage(`Image generation stopped by user.`, "bot", null, new Date());
    } else {
      addMessage(
        `Sorry, there was an error generating the image: ${error.message}. Please try again.`,
        "bot",
        null,
        new Date()
      );
    }
  } finally {
    textInput.value = "";
    textInput.style.height = "auto";
    textInput.focus();
    showSendButton(); // Show send button
    abortController = null;
    if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
  }
}

async function uploadImage(file, caption) {
  const loader = document.getElementById("loader");
  loader.style.display = "block"; // Show loader for upload
  showStopButton(); // Show stop button
  stopSpeaking(); // Stop AI speech if any

  abortController = new AbortController();
  const signal = abortController.signal;

  try {
    const formData = new FormData();
    formData.append("image", file);
    if (caption) {
      formData.append("caption", caption);
    }
    formData.append("chat_id", currentChatId);

    const response = await fetch(`${window.location.origin}/upload_image`, {
      method: "POST",
      body: formData,
      signal: signal, // Pass the abort signal
    });
    const data = await response.json();

    loader.style.display = "none"; // Hide loader after response
    if (data && data.response) {
      // Assuming the backend has already saved the user's message (caption + image) correctly.
      // Now, display the AI's response (which might contain extracted text) as a separate bot message.
      if (data.image_urls && data.image_urls.length > 0) {
        addMessage(data.response, "bot", data.image_urls, new Date());
        if (isVoiceTalkActive && data.response) speakText(data.response);
      } else {
        addMessage(data.response, "bot", null, new Date());
        if (isVoiceTalkActive && data.response) speakText(data.response);
      }
    } else {
      console.error(
        "Image upload failed: Received an empty response or no AI response."
      );
      addMessage(
        "Received an empty response from the server after image upload. Please try again.",
        "bot",
        null,
        new Date()
      );
    }
  } catch (error) {
    loader.style.display = "none"; // Hide loader on error
    if (error.name === "AbortError") {
      console.log("Image upload aborted by user.");
      addMessage(`Image upload stopped by user.`, "bot", null, new Date());
    } else {
      addMessage(
        `Failed to upload image due to network error: ${error.message}. Please try again.`,
        "bot",
        null,
        new Date()
      );
    }
  } finally {
    clearImagePreview(); // Clear preview in all cases
    showSendButton(); // Show send button
    abortController = null;
    if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
  }
}

// --- DEPRECATED: performWebSearch is no longer directly called from frontend for display ---
// It's kept here for reference but the logic is now handled by askAI with web_search flag
/*
async function performWebSearch(query) {
const textInput = document.getElementById('text-input');
const loader = document.getElementById('loader');
loader.style.display = 'block'; 
showStopButton(); // Show stop button
stopSpeaking(); // Stop AI speech if any

abortController = new AbortController();
const signal = abortController.signal;

const BACKEND_WEB_SEARCH_ENDPOINT = `${window.location.origin}/web_search`; 

try {
const response = await fetch(BACKEND_WEB_SEARCH_ENDPOINT, {
  method: 'POST',
  headers: {
      'Content-Type': 'application/json',
  },
  body: JSON.stringify({ q: query, chat_id: currentChatId }),
  signal: signal // Pass the abort signal
});

if (!response.ok) {
  let errorMessage = `Web search failed with status ${response.status}`;

  try {
      const cloned = response.clone(); // Clone the stream
      const errorData = await cloned.json();
      if (errorData?.error) {
          errorMessage = `Web search failed: ${errorData.error}`;
      }
  } catch (e) {
      try {
          const fallbackCloned = response.clone(); // Clone again to read text
          const text = await fallbackCloned.text();
          if (text && text.startsWith('<')) {
              errorMessage = "Server returned an HTML error page. Check if your backend route returns JSON.";
          } else {
              errorMessage = `Unexpected error response: ${text}`;
          }
      } catch (finalError) {
          errorMessage = `Could not read error body: ${finalError.message}`;
      }
  }

  throw new Error(errorMessage);
}

const data = await response.json();
loader.style.display = 'none';

// The backend now sends the formatted response directly in data.response
const botResponseText = data.response; 

addMessage(botResponseText, 'bot', null, new Date()); // Use addMessage for non-streaming
if (isVoiceTalkActive && botResponseText) speakText(botResponseText);

} catch (error) {
loader.style.display = 'none'; // Hide loader on error
if (error.name === 'AbortError') {
  console.log('Web search aborted by user.');
  addMessage(`Web search stopped by user.`, 'bot', null, new Date());
} else {
  addMessage(`Sorry, there was an error performing the web search: ${error.message}. Please try again.`, 'bot', null, new Date());
}
} finally {
textInput.value = '';
textInput.style.height = 'auto';
textInput.focus();
showSendButton(); // Show send button
abortController = null;
if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
}
}
*/
// --- END DEPRECATED: Web Search Functionality ---

async function summarizeText(textToSummarize) {
  try {
    const response = await fetch(`${window.location.origin}/summarize_text`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        text: textToSummarize,
        chat_id: currentChatId,
      }),
    });
    const data = await response.json();
    if (data && data.summary) {
      return data.summary;
    } else {
      console.error(
        "Summarization failed:",
        data.error || "No summary returned."
      );
      return null;
    }
  } catch (error) {
    console.error("Error summarizing text:", error);
    return null;
  }
}

async function checkGrammarAndStyle(text) {
  const textInput = document.getElementById("text-input");
  const loader = document.getElementById("loader");
  loader.style.display = "block";
  showStopButton(); // Show stop button
  stopSpeaking(); // Stop AI speech if any

  abortController = new AbortController();
  const signal = abortController.signal;

  try {
    const formData = new FormData();
    formData.append("text", text);
    formData.append("chat_id", currentChatId);

    const response = await fetch(
      `${window.location.origin}/check_grammar_style`,
      {
        method: "POST",
        body: formData,
        signal: signal, // Pass the abort signal
      }
    );
    const data = await response.json();
    loader.style.display = "none";
    if (data && data.corrected_text) {
      addMessage(data.corrected_text, "bot", null, new Date());
      if (isVoiceTalkActive && data.corrected_text)
        speakText(data.corrected_text);
    } else {
      console.error(
        "Grammar/Style check failed:",
        data.error || "No response returned."
      );
      addMessage(
        data.error || "Failed to check grammar and style.",
        "bot",
        null,
        new Date()
      );
    }
  } catch (error) {
    loader.style.display = "none"; // Hide loader on error
    if (error.name === "AbortError") {
      console.log("Grammar check aborted by user.");
      addMessage(`Grammar check stopped by user.`, "bot", null, new Date());
    } else {
      addMessage(
        `Sorry, an error occurred while checking the grammar and style: ${error.message}. Please try again.`,
        "bot",
        null,
        new Date()
      );
    }
  } finally {
    textInput.value = "";
    textInput.style.height = "auto";
    textInput.focus();
    showSendButton(); // Show send button
    abortController = null;
    if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
  }
}

async function explainCode(code) {
  const textInput = document.getElementById("text-input");
  const loader = document.getElementById("loader");
  loader.style.display = "block";
  showStopButton(); // Show stop button
  stopSpeaking(); // Stop AI speech if any

  abortController = new AbortController();
  const signal = abortController.signal;

  try {
    const formData = new FormData();
    formData.append("code", code);
    formData.append("chat_id", currentChatId);

    const response = await fetch(`${window.location.origin}/explain_code`, {
      method: "POST",
      body: formData,
      signal: signal, // Pass the abort signal
    });
    const data = await response.json();
    loader.style.display = "none";
    if (data && data.explanation) {
      addMessage(data.explanation, "bot", null, new Date());
      if (isVoiceTalkActive && data.explanation) speakText(data.explanation);
    } else {
      console.error(
        "Code explanation failed:",
        data.error || "No response returned."
      );
      addMessage(
        data.error || "Failed to explain code.",
        "bot",
        null,
        new Date()
      );
    }
  } catch (error) {
    loader.style.display = "none"; // Hide loader on error
    if (error.name === "AbortError") {
      console.log("Code explanation aborted by user.");
      addMessage(`Code explanation stopped by user.`, "bot", null, new Date());
    } else {
      addMessage(
        `Sorry, an error occurred while explaining the code: ${error.message}. Please try again.`,
        "bot",
        null,
        new Date()
      );
    }
  } finally {
    textInput.value = "";
    textInput.style.height = "auto";
    textInput.focus();
    showSendButton(); // Show send button
    abortController = null;
    if (isVoiceTalkActive) startListening(); // Restart listening after AI finishes
  }
}

// UI Functions
function showModal() {
  document.getElementById("confirmModal").style.display = "flex";
}

function hideModal() {
  document.getElementById("confirmModal").style.display = "none";
}

// Show image preview in the input area
function showImagePreview(file) {
  const imagePreviewContainer = document.getElementById(
    "image-preview-container"
  );
  const imagePreview = document.getElementById("image-preview");
  const clearImageBtn = document.getElementById("clear-image-btn");

  const reader = new FileReader();
  reader.onload = function (e) {
    imagePreview.src = e.target.result;
    imagePreview.style.display = "block";
    imagePreviewContainer.style.display = "flex";
    clearImageBtn.style.display = "flex";
  };
  reader.readAsDataURL(file);
}

// Clear image preview from the input area
function clearImagePreview() {
  const imagePreviewContainer = document.getElementById(
    "image-preview-container"
  );
  const imagePreview = document.getElementById("image-preview");
  const clearImageBtn = document.getElementById("clear-image-btn");
  const takePhotoInput = document.getElementById("take-photo-input"); // Get new inputs
  const uploadPhotoInput = document.getElementById("upload-photo-input");
  const desktopFileInput = document.getElementById("desktop-file-input"); // NEW: Get desktop input

  imagePreview.src = "#";
  imagePreview.style.display = "none";
  imagePreviewContainer.style.display = "none";
  clearImageBtn.style.display = "none";
  if (takePhotoInput) takePhotoInput.value = ""; // Clear file inputs
  if (uploadPhotoInput) uploadPhotoInput.value = "";
  if (desktopFileInput) desktopFileInput.value = ""; // NEW: Clear desktop file input
}

// Toggle full screen mode
window.toggleFullScreen = function () {
  const body = document.body;
  isFullScreen = !isFullScreen;

  if (isFullScreen) {
    body.classList.add("full-screen-mode");
  } else {
    body.classList.remove("full-screen-mode");
    // Restore sidebar visibility based on previous state if on desktop
    if (window.innerWidth > 768 && !sidebarHidden) {
      document.getElementById("sidebar").classList.remove("collapsed");
      document.querySelector(".main").classList.remove("full-width");
    }
  }
  // Ensure the correct sidebar toggle button is shown/hidden after full screen toggle
  updateSidebarToggleButtonVisibility();
};

window.clearAllChats = function () {
  showModal();
};
window.startNewChat = async function (isInitialLoad = false) {
  const chatbox = document.getElementById("chatbox");
  const textInput = document.getElementById("text-input");
  const modelGeneralRadio = document.getElementById("modelGeneral");

  try {
    const response = await fetch(`${window.location.origin}/start_new_chat`, {
      method: "POST",
    });
    const data = await response.json();

    if (data.chat_id) {
      currentChatId = data.chat_id;

      // Clear chatbox first
      chatbox.innerHTML = "";

      // Add the welcome placeholder with logo
      const placeholderDiv = document.createElement("div");
      placeholderDiv.id = "new-chat-placeholder";
      placeholderDiv.className = "new-chat-placeholder";
      placeholderDiv.innerHTML = `
<img src="/static/images/vexara-new1-removebg-preview.png" alt="V" style="width: 60px; height: 60px; object-fit: contain;" />
          <span>How can I help you?</span>
`;
      chatbox.appendChild(placeholderDiv);

      // Reset input field
      textInput.value = "";
      textInput.style.height = "auto";
      textInput.focus();
      textInput.setAttribute("required", "");
      textInput.placeholder = "Ask anything";

      clearImagePreview(); // Clear any existing image preview
      modelGeneralRadio.checked = true; // Set General Talk as default

      // Update chat history **after adding placeholder**
      await updateChatHistory();

      // If no messages loaded, make sure placeholder stays
      if (chatbox.children.length === 0) {
        chatbox.appendChild(placeholderDiv);
      }
    } else {
      console.error("Failed to get a new chat ID from backend.");
      addMessage(
        "Failed to start new chat. Please try refreshing the page.",
        "bot",
        null,
        new Date()
      );
    }
  } catch (error) {
    console.error("Error starting new chat:", error);
    addMessage(
      "Failed to start new chat due to network error. Please try again.",
      "bot",
      null,
      new Date()
    );
  }
};

window.toggleDarkMode = function () {
  document.body.classList.toggle("dark-mode");
  if (document.body.classList.contains("dark-mode")) {
    localStorage.setItem("darkMode", "enabled");
  } else {
    localStorage.removeItem("darkMode");
  }
};

// Handles sidebar visibility for both desktop collapse and mobile slide-out
window.toggleSidebar = function () {
  const sidebar = document.getElementById("sidebar");
  const mainContent = document.querySelector(".main");

  if (window.innerWidth <= 768 || isFullScreen) {
    // Mobile or Full Screen mode
    sidebar.classList.toggle("visible");
  } else {
    // Desktop
    sidebar.classList.toggle("collapsed");
    mainContent.classList.toggle("full-width");
    sidebarHidden = sidebar.classList.contains("collapsed"); // Update hidden state
  }
  updateSidebarToggleButtonVisibility(); // Update button visibility after toggling
};

// Helper function to manage sidebar toggle button visibility
function updateSidebarToggleButtonVisibility() {
  const sidebar = document.getElementById("sidebar");
  const showSidebarBtn = document.getElementById("showSidebarBtn");
  const sidebarToggleButton = document.getElementById("sidebarToggleButton"); // The button inside the sidebar

  if (window.innerWidth <= 768 || isFullScreen) {
    // Mobile or Full Screen mode
    if (sidebar.classList.contains("visible")) {
      showSidebarBtn.style.display = "none";
      sidebarToggleButton.style.display = "block";
      sidebarToggleButton.querySelector("i").className = "fi fi-rr-sidebar"; // Same icon
    } else {
      showSidebarBtn.style.display = "flex";
      sidebarToggleButton.style.display = "none";
      showSidebarBtn.querySelector("i").className = "fi fi-rr-sidebar"; // Same icon
    }
  } else {
    // Desktop
    if (sidebar.classList.contains("collapsed")) {
      showSidebarBtn.style.display = "flex"; // Show floating button to expand
      sidebarToggleButton.style.display = "none"; // Hide internal toggle
      showSidebarBtn.querySelector("i").className = "fi fi-rr-sidebar"; // Same icon
    } else {
      showSidebarBtn.style.display = "none"; // Hide floating button
      sidebarToggleButton.style.display = "block"; // Show internal toggle
      sidebarToggleButton.querySelector("i").className = "fi fi-rr-sidebar"; // Same icon
    }
  }
}

// Functions to toggle visibility of Send and Stop buttons
function showSendButton() {
  if (isVoiceTalkActive) return; // Do not show if voice talk is active
  document.getElementById("send-btn").style.display = "flex";
  document.getElementById("stop-btn").style.display = "none";
}

function showStopButton() {
  if (isVoiceTalkActive) return; // Do not show if voice talk is active
  document.getElementById("send-btn").style.display = "none";
  document.getElementById("stop-btn").style.display = "flex";
}

// NEW: Functions for the subtle talking animation
function showTalkingAnimation() {
  const talkingAnimation = document.getElementById("talking-animation");
  if (talkingAnimation) {
    talkingAnimation.classList.add("active");
  }
}

function hideTalkingAnimation() {
  const talkingAnimation = document.getElementById("talking-animation");
  if (talkingAnimation) {
    talkingAnimation.classList.remove("active");
  }
}

// Voice Talk Functions
const voiceTalkBtn = document.getElementById("voice-talk-btn");
const micIcon = voiceTalkBtn.querySelector("i");
const voiceModeOverlay = document.getElementById("voice-mode-overlay");
const mainContentElement = document.querySelector(".main"); // Renamed to avoid conflict with local variable
const micControlBtn = document.getElementById("mic-control-btn");
const closeVoiceModeBtn = document.getElementById("close-voice-mode-btn");
const voiceStatusTextOverlay = voiceModeOverlay.querySelector(".status-text");
const screenShareBtn = document.getElementById("screen-share-btn"); // New screen share button

function initializeSpeechRecognition() {
  if ("SpeechRecognition" in window || "webkitSpeechRecognition" in window) {
    recognition = new (window.SpeechRecognition ||
      window.webkitSpeechRecognition)();
    recognition.continuous = false; // Only listen for a single utterance
    recognition.interimResults = false; // Only return final results
    recognition.lang = "en-US"; // Set language

    recognition.onstart = () => {
      isListening = true;
      micControlBtn.classList.add("mic-active");
      micControlBtn.querySelector("i").className = "fas fa-microphone-alt"; // Listening icon
      voiceStatusTextOverlay.textContent = "Listening...";
      console.log("Speech recognition started.");
      stopSpeaking(); // Stop AI speech if user starts talking
      startVoiceVisualizer(false); // Start visualizer for user input
    };

    recognition.onresult = (event) => {
      const transcript = event.results[0][0].transcript;
      document.getElementById("text-input").value = transcript;
      console.log("Speech recognized:", transcript);
      // Automatically submit the form after speech is recognized
      document
        .getElementById("multi-action-form")
        .dispatchEvent(new Event("submit", { cancelable: true }));
    };

    recognition.onerror = (event) => {
      console.error("Speech recognition error:", event.error);
      micControlBtn.classList.remove("mic-active");
      micControlBtn.querySelector("i").className = "fas fa-microphone"; // Default icon on error
      isListening = false;
      stopVoiceVisualizer(); // Stop visualizer on error
      let errorMessage = "Speech error. Tap mic to retry.";
      if (event.error === "not-allowed") {
        errorMessage = "Microphone permission denied. Please allow access.";
        addMessage(
          "Microphone access denied. Please enable microphone permissions for this site in your browser settings to use voice features.",
          "bot",
          null,
          new Date()
        );
      } else if (event.error === "no-speech") {
        errorMessage = "No speech detected. Please try again.";
      } else if (event.error === "audio-capture") {
        errorMessage = "Microphone not found or busy. Check connections.";
      } else if (event.error === "network") {
        errorMessage = "Network error during speech recognition.";
      }
      voiceStatusTextOverlay.textContent = errorMessage;
      // Do NOT automatically restart here, let user tap again
    };

    recognition.onend = () => {
      console.log("Speech recognition ended.");
      isListening = false;
      micControlBtn.classList.remove("mic-active");
      micControlBtn.querySelector("i").className = "fas fa-microphone"; // Default icon
      stopVoiceVisualizer(); // Stop visualizer when listening ends
      if (isVoiceTalkActive && !isSpeaking) {
        voiceStatusTextOverlay.textContent = "Standard voice"; // Reset status text
        // Only restart listening if AI is not speaking and voice mode is still active
        // This will be handled by finalizeStreamingBotMessage or micControlBtn click
      } else if (!isVoiceTalkActive) {
        voiceStatusTextOverlay.textContent = "Standard voice";
      }
    };
  } else {
    voiceTalkBtn.disabled = true;
    voiceTalkBtn.title = "Voice talk not supported in your browser.";
    console.warn("Web Speech API not supported in this browser.");
    // Provide user feedback directly in chat if it's the first time they try
    addMessage(
      "Your browser does not support Web Speech Recognition. Please use a compatible browser like Chrome or Edge.",
      "bot",
      null,
      new Date()
    );
  }
}

function startListening() {
  if (recognition && isVoiceTalkActive && !isListening && !isSpeaking) {
    // Ensure not speaking
    try {
      recognition.start();
    } catch (e) {
      console.warn("Recognition already started or other error:", e);
      if (e.message.includes("already started")) {
        // Ignore if already started, but log for debugging
      } else if (e.message.includes("permission denied")) {
        voiceStatusTextOverlay.textContent =
          "Microphone permission denied. Please allow access.";
        addMessage(
          "Microphone access denied. Please enable microphone permissions for this site in your browser settings to use voice features.",
          "bot",
          null,
          new Date()
        );
      } else {
        voiceStatusTextOverlay.textContent =
          "Error starting mic. Tap to retry.";
        addMessage(
          "An error occurred trying to start the microphone: " + e.message,
          "bot",
          null,
          new Date()
        );
      }
    }
  } else if (!recognition) {
    voiceStatusTextOverlay.textContent = "Speech API not available.";
    addMessage(
      "Web Speech API is not available in your browser.",
      "bot",
      null,
      new Date()
    );
  }
}

function stopListening() {
  if (recognition && isListening) {
    recognition.stop();
  }
}

// Function to set the AI's voice
function setAIVoice() {
  const voices = synth.getVoices();
  // Try to find a specific voice, e.g., a female voice, or one with a clear, standard accent.
  // You might need to inspect `voices` array in your browser's console to find suitable names.
  // Common names: 'Google US English', 'Microsoft Zira - English (United States)', 'Samantha' (iOS)
  selectedVoice =
    voices.find(
      (voice) =>
        voice.name.includes("Google US English") &&
        voice.lang === "en-US" &&
        voice.gender === "female"
    ) ||
    voices.find(
      (voice) => voice.name.includes("Zira") && voice.lang === "en-US"
    ) ||
    voices.find(
      (voice) => voice.lang === "en-US" && voice.name.includes("Female")
    ) ||
    voices.find((voice) => voice.lang === "en-US") ||
    voices[0]; // Fallback to the first available voice

  if (selectedVoice) {
    console.log("AI Voice selected:", selectedVoice.name, selectedVoice.lang);
  } else {
    console.warn("Could not find a specific AI voice, using default.");
  }
}

function speakText(text) {
  if (!isVoiceTalkActive || !synth || !selectedVoice) {
    console.warn(
      "Speech synthesis not active, synth not available, or no voice selected. Cannot speak."
    );
    return;
  }

  speechQueue.push(text); // Add text to the queue
  processSpeechQueue(); // Start/continue processing the queue
}

function processSpeechQueue() {
  if (isProcessingSpeechQueue || speechQueue.length === 0) {
    return; // Already processing or nothing to speak
  }

  isProcessingSpeechQueue = true;
  stopListening(); // Stop listening while AI is speaking

  const textToSpeak = speechQueue.shift(); // Get the next text from the queue
  const utterance = new SpeechSynthesisUtterance(textToSpeak);
  utterance.lang = "en-US";
  utterance.pitch = 1.0; // Default pitch (0.1 to 2.0)
  utterance.rate = 1.0; // Default rate (0.1 to 10.0)
  utterance.voice = selectedVoice; // Apply the selected voice

  utterance.onstart = () => {
    isSpeaking = true;
    micControlBtn.classList.add("mic-active");
    micControlBtn.querySelector("i").className = "fas fa-volume-up"; // Speaking icon
    voiceStatusTextOverlay.textContent = "Speaking...";
    console.log("Speech synthesis started.");
    startVoiceVisualizer(true); // Start visualizer for AI speech (full screen overlay)
    showTalkingAnimation(); // Show subtle animation at bottom
  };

  utterance.onend = () => {
    console.log("Speech synthesis ended.");
    isSpeaking = false;
    stopVoiceVisualizer(); // Stop visualizer
    hideTalkingAnimation(); // Hide subtle animation
    isProcessingSpeechQueue = false; // Mark as done with current utterance

    if (speechQueue.length > 0) {
      processSpeechQueue(); // Process next in queue
    } else {
      // Only reset controls and restart listening if the entire queue is empty
      micControlBtn.classList.remove("mic-active");
      micControlBtn.querySelector("i").className = "fas fa-microphone"; // Default icon
      if (isVoiceTalkActive) {
        voiceStatusTextOverlay.textContent = "Standard voice"; // Reset status text
        startListening(); // Restart listening after AI finishes speaking
      }
    }
  };

  utterance.onerror = (event) => {
    console.error("Speech synthesis error:", event.error);
    isSpeaking = false;
    stopVoiceVisualizer(); // Stop visualizer
    hideTalkingAnimation(); // Hide subtle animation
    isProcessingSpeechQueue = false; // Mark as done with current utterance

    // Clear the rest of the queue on error to prevent cascading issues
    speechQueue = [];

    micControlBtn.classList.remove("mic-active");
    micControlBtn.querySelector("i").className = "fas fa-microphone"; // Default icon on error
    if (isVoiceTalkActive) {
      voiceStatusTextOverlay.textContent = "Speech error. Tap mic to retry."; // More informative error
      startListening(); // Try to restart listening
    }
  };

  synth.speak(utterance);
}

function stopSpeaking() {
  if (isSpeaking || isProcessingSpeechQueue) {
    synth.cancel(); // Stops current utterance
    speechQueue = []; // Clear any pending utterances
    isSpeaking = false;
    isProcessingSpeechQueue = false;
    micControlBtn.classList.remove("mic-active");
    micControlBtn.querySelector("i").className = "fas fa-microphone"; // Default icon
    stopVoiceVisualizer(); // Stop any ongoing visualizer
    hideTalkingAnimation(); // Ensure subtle animation is hidden
  }
}

// Web Audio API Visualizer Logic
async function initializeVoiceVisualizer() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
    console.warn("getUserMedia not supported in this browser.");
    return;
  }

  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048; // Fast Fourier Transform size
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength); // Array to hold frequency data

    canvas = document.getElementById("voice-circle-canvas");
    canvasCtx = canvas.getContext("2d");

    // Set canvas dimensions dynamically
    const setCanvasSize = () => {
      const size = Math.min(window.innerWidth, window.innerHeight) * 0.5; // Max 50% of smaller dimension
      canvas.width = size;
      canvas.height = size;
      canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear after resize
    };
    setCanvasSize();
    window.addEventListener("resize", setCanvasSize);

    // Get microphone stream only once
    if (!microphoneStream) {
      microphoneStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
      });
      const source = audioContext.createMediaStreamSource(microphoneStream);
      source.connect(analyser);
      // analyser.connect(audioContext.destination); // Connect to speakers for monitoring, optional
    }
  } catch (err) {
    console.error("Error accessing microphone for visualizer:", err);
    // Disable voice features if mic access fails
    voiceTalkBtn.disabled = true;
    voiceTalkBtn.title = "Microphone access denied or not available.";
    micControlBtn.disabled = true;
    micControlBtn.title = "Microphone access denied or not available.";
    addMessage(
      "Microphone access is required for voice visualization and input. Please enable it in your browser settings.",
      "bot",
      null,
      new Date()
    );
  }
}

function startVoiceVisualizer(isAIVoice = false) {
  if (!analyser || !canvasCtx) return;

  cancelAnimationFrame(animationFrameId); // Stop any existing animation

  const draw = () => {
    animationFrameId = requestAnimationFrame(draw);

    analyser.getByteFrequencyData(dataArray); // Get frequency data

    canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const maxRadius = Math.min(centerX, centerY) * 0.7; // Max size

    // Calculate overall volume (amplitude)
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      sum += dataArray[i];
    }
    let average = sum / bufferLength;
    let normalizedVolume = average / 128; // Normalize to 0-2 range (can exceed 1 for loud sounds)
    normalizedVolume = Math.min(2, Math.max(0, normalizedVolume)); // Clamp between 0 and 2

    const baseCircleRadius = Math.min(centerX, centerY) * 0.4;
    const maxCircleExpansion = Math.min(centerX, centerY) * 0.3; // Max expansion beyond base

    // Dynamic properties based on AI voice or user voice
    const mainColor = isAIVoice ? "106, 13, 173" : "16, 163, 127"; // Accent vs Primary
    const numRings = isAIVoice ? 7 : 5; // More rings for AI
    const baseLineWidth = isAIVoice ? 3 : 2; // Thicker lines for AI
    const maxLineWidthBoost = isAIVoice ? 7 : 5; // More boost for AI

    // Add a subtle rotation for AI voice
    if (isAIVoice) {
      canvasCtx.save();
      canvasCtx.translate(centerX, centerY);
      canvasCtx.rotate((Date.now() * 0.001) % (2 * Math.PI)); // Faster continuous rotation for AI voice
      canvasCtx.translate(-centerX, -centerY);
    }

    for (let i = 0; i < numRings; i++) {
      const ringOffset = i * (maxCircleExpansion / numRings);
      let currentRadius =
        baseCircleRadius +
        normalizedVolume * maxCircleExpansion * 0.5 +
        ringOffset;

      // More dynamic animation for AI voice
      const animationFactor = isAIVoice
        ? Math.sin(Date.now() * 0.008 + i * 0.7) * 0.07
        : Math.sin(Date.now() * 0.005 + i * 0.5) * 0.05;
      currentRadius *= 1 + animationFactor;

      const opacity = 0.1 + normalizedVolume * 0.4 * (1 - i / numRings);
      const lineWidth =
        baseLineWidth +
        normalizedVolume * maxLineWidthBoost * (1 - i / numRings);

      canvasCtx.beginPath();
      canvasCtx.arc(centerX, centerY, currentRadius, 0, 2 * Math.PI);
      canvasCtx.strokeStyle = `rgba(${mainColor}, ${opacity})`;
      canvasCtx.lineWidth = lineWidth;
      canvasCtx.stroke();
    }

    // Draw a central solid circle that pulses more
    const centralRadius =
      baseCircleRadius * 0.8 + normalizedVolume * baseCircleRadius * 0.2;
    canvasCtx.beginPath();
    canvasCtx.arc(centerX, centerY, centralRadius, 0, 2 * Math.PI);
    canvasCtx.fillStyle = `rgba(${mainColor}, ${0.5 + normalizedVolume * 0.4})`; // More opaque for AI
    canvasCtx.fill();

    if (isAIVoice) {
      canvasCtx.restore(); // Restore canvas state after rotation
    }
  };
  draw();
}

function stopVoiceVisualizer() {
  cancelAnimationFrame(animationFrameId);
  if (canvasCtx) {
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
  }
}

voiceTalkBtn.addEventListener("click", () => {
  isVoiceTalkActive = !isVoiceTalkActive;

  if (isVoiceTalkActive) {
    console.log("Voice Talk ON");
    voiceModeOverlay.classList.add("active"); // Show full-screen overlay
    mainContentElement.style.display = "none"; // Hide main chat UI
    voiceStatusTextOverlay.textContent = "Standard voice"; // Initial status for overlay
    startListening(); // Attempt to start listening
  } else {
    console.log("Voice Talk OFF");
    stopListening();
    stopSpeaking(); // Ensure all speech and visualizer are stopped
    stopVoiceVisualizer(); // Stop visualizer when exiting voice mode
    stopScreenShare(); // Stop screen share if active

    voiceModeOverlay.classList.remove("active"); // Hide full-screen overlay
    mainContentElement.style.display = "flex"; // Show main chat UI

    micControlBtn.classList.remove("mic-active"); // Reset mic button on overlay
    micControlBtn.querySelector("i").className = "fas fa-microphone";
  }
});

// Event listener for the mic button on the overlay
micControlBtn.addEventListener("click", () => {
  if (isListening) {
    stopListening();
    voiceStatusTextOverlay.textContent = "Tap mic to speak."; // Prompt user to tap again
  } else {
    startListening();
  }
});

// Event listener for the close button on the overlay
closeVoiceModeBtn.addEventListener("click", () => {
  isVoiceTalkActive = false; // Deactivate voice mode
  // Manually trigger the state change that voiceTalkBtn.click() would do
  stopListening();
  stopSpeaking();
  stopVoiceVisualizer();
  stopScreenShare(); // Stop screen share if active

  voiceModeOverlay.classList.remove("active");
  mainContentElement.style.display = "flex";
  micControlBtn.classList.remove("mic-active");
  micControlBtn.querySelector("i").className = "fas fa-microphone";
  showSendButton(); // Ensure send button is visible if not in voice mode
});

// NEW: Screen Share Functions
screenShareBtn.addEventListener("click", () => {
  if (isScreenSharing) {
    stopScreenShare();
  } else {
    startScreenShare();
  }
});

async function startScreenShare() {
  if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
    addMessage(
      "Screen sharing not supported in your browser.",
      "bot",
      null,
      new Date()
    );
    if (isVoiceTalkActive)
      speakText("Screen sharing not supported in your browser.");
    console.warn("getDisplayMedia not supported.");
    return;
  }

  try {
    // Request screen share stream
    screenShareStream = await navigator.mediaDevices.getDisplayMedia({
      video: true,
      audio: false,
    });
    screenShareVideoElement.srcObject = screenShareStream;
    screenSharePreviewContainer.style.display = "flex"; // Show preview

    isScreenSharing = true;
    screenShareBtn.classList.add("screen-share-active");
    screenShareBtn.querySelector("i").className = "fas fa-stop-circle"; // Stop icon

    // Listen for when the user stops sharing directly from the browser's UI
    screenShareStream.getVideoTracks()[0].onended = () => {
      console.log("Screen share ended by user.");
      stopScreenShare();
    };

    // Start capturing and sending frames
    screenShareInterval = setInterval(captureAndSendScreenFrame, 2000); // Send frame every 2 seconds
    addMessage(
      "Screen sharing started. I will analyze your screen for issues.",
      "bot",
      null,
      new Date()
    );
    if (isVoiceTalkActive)
      speakText(
        "Screen sharing started. I will analyze your screen for issues."
      );
  } catch (err) {
    console.error("Error starting screen share:", err);
    addMessage(
      "Could not start screen sharing. Please ensure you grant permission.",
      "bot",
      null,
      new Date()
    );
    if (isVoiceTalkActive)
      speakText(
        "Could not start screen sharing. Please ensure you grant permission."
      );
    isScreenSharing = false;
    screenShareBtn.classList.remove("screen-share-active");
    screenShareBtn.querySelector("i").className = "fas fa-desktop";
    screenSharePreviewContainer.style.display = "none";
  }
}

function stopScreenShare() {
  if (screenShareStream) {
    screenShareStream.getTracks().forEach((track) => track.stop());
    screenShareStream = null;
  }
  if (screenShareInterval) {
    clearInterval(screenShareInterval);
    screenShareInterval = null;
  }
  isScreenSharing = false;
  screenShareBtn.classList.remove("screen-share-active");
  screenShareBtn.querySelector("i").className = "fas fa-desktop"; // Reset icon
  screenSharePreviewContainer.style.display = "none"; // Hide preview
  addMessage("Screen sharing stopped.", "bot", null, new Date());
  if (isVoiceTalkActive) speakText("Screen sharing stopped.");
}

async function captureAndSendScreenFrame() {
  if (!screenShareVideoElement || !isScreenSharing) return;

  // Set canvas dimensions to match video stream
  screenCaptureCanvas.width = screenShareVideoElement.videoWidth;
  screenCaptureCanvas.height = screenShareVideoElement.videoHeight;

  // Draw the current video frame onto the canvas
  screenCaptureCtx.drawImage(
    screenShareVideoElement,
    0,
    0,
    screenCaptureCanvas.width,
    screenCaptureCanvas.height
  );

  // Get base64 image data from the canvas
  const imageDataUrl = screenCaptureCanvas.toDataURL("image/jpeg", 0.7); // JPEG for compression, 70% quality
  const base64Image = imageDataUrl.split(",")[1]; // Remove "data:image/jpeg;base64," prefix

  try {
    const formData = new FormData();
    formData.append("image", base64Image);
    formData.append("chat_id", currentChatId);
    formData.append(
      "instruction",
      "Analyze this screenshot for any UI/code issues, errors, or areas for improvement. Suggest specific fixes or next steps, including code if applicable."
    );

    const response = await fetch(
      `${window.location.origin}/process_screen_frame`,
      {
        method: "POST",
        body: formData,
      }
    );

    const data = await response.json();
    if (data && data.response) {
      addMessage(
        `**Screen Analysis:** ${data.response}`,
        "bot",
        null,
        new Date()
      );
      if (isVoiceTalkActive) speakText(data.response);
    } else {
      console.error("Screen analysis failed: No response from AI.");
    }
  } catch (error) {
    console.error("Error sending screen frame to AI:", error);
    // Optionally add a message to the chat about the error
  }
}

// NEW: Code Update Modal Functions
const codeUpdateModal = document.getElementById("codeUpdateModal");
const fileToUpdateSelect = document.getElementById("fileToUpdateSelect");
const codeUpdateTextarea = document.getElementById("codeUpdateTextarea");
const applyCodeUpdateBtn = document.getElementById("applyCodeUpdateBtn");

window.openCodeUpdateModal = function (suggestedCode = "", fileType = "html") {
  codeUpdateTextarea.value = suggestedCode;
  // Set the selected file type in the dropdown
  if (fileToUpdateSelect) {
    const options = Array.from(fileToUpdateSelect.options);
    const matchingOption = options.find((option) =>
      option.value.includes(fileType)
    );
    if (matchingOption) {
      fileToUpdateSelect.value = matchingOption.value;
    } else {
      fileToUpdateSelect.value = "index.html"; // Default
    }
  }
  codeUpdateModal.style.display = "flex";
};

applyCodeUpdateBtn.addEventListener("click", async () => {
  const fileName = fileToUpdateSelect.value;
  const fileContent = codeUpdateTextarea.value;

  if (!fileName || !fileContent) {
    addMessage(
      "Please select a file and provide content to update.",
      "bot",
      null,
      new Date()
    );
    return;
  }

  addMessage(`Attempting to update ${fileName}...`, "user", null, new Date());
  codeUpdateModal.style.display = "none"; // Hide modal immediately

  try {
    const formData = new FormData();
    formData.append("file_name", fileName);
    formData.append("file_content", fileContent);

    const response = await fetch(`${window.location.origin}/update_file`, {
      method: "POST",
      body: formData,
    });

    const data = await response.json();
    if (data.status === "success") {
      addMessage(
        `Successfully updated ${fileName}: ${data.message}`,
        "bot",
        null,
        new Date()
      );
    } else {
      addMessage(
        `Failed to update ${fileName}: ${data.message}`,
        "bot",
        null,
        new Date()
      );
    }
  } catch (error) {
    console.error("Error applying code update:", error);
    addMessage(
      `Error communicating with server for file update: ${error.message}`,
      "bot",
      null,
      new Date()
    );
  }
});

async function updateChatHistory() {
  const chatHistoryList = document.getElementById("chat-history-list");
  chatHistoryList.innerHTML = ""; // Clear existing history
  try {
    const response = await fetch(
      `${window.location.origin}/get_chat_history_list`
    );
    const chatSummaries = await response.json();

    if (chatSummaries.length === 0) {
      await startNewChat(true); // Start a new chat if no history
    } else {
      chatSummaries.forEach((chatSummary) => {
        const chatLink = document.createElement("a");
        chatLink.href = "#";
        chatLink.className = `chat-link ${
          chatSummary.id === currentChatId ? "active" : ""
        }`;
        chatLink.setAttribute("data-chat-id", chatSummary.id); // Store chat ID
        chatLink.setAttribute("data-chat-title", chatSummary.title); // Store chat title
        chatLink.setAttribute("role", "option");
        chatLink.setAttribute(
          "aria-selected",
          chatSummary.id === currentChatId ? "true" : "false"
        );
        chatLink.setAttribute("tabindex", "0"); // Make it focusable

        const chatTitleSpan = document.createElement("span");
        chatTitleSpan.textContent = chatSummary.title;
        chatLink.appendChild(chatTitleSpan);

        const actionsDiv = document.createElement("div");
        actionsDiv.className = "chat-link-actions";

        const renameBtn = document.createElement("button");
        renameBtn.className = "rename-chat-btn";
        renameBtn.innerHTML = '<i class="fas fa-edit" aria-hidden="true"></i>';
        renameBtn.title = "Rename Chat";
        renameBtn.setAttribute(
          "aria-label",
          `Rename chat ${chatSummary.title}`
        );
        renameBtn.onclick = (e) => {
          e.stopPropagation(); // Prevent loading chat when clicking rename
          renameChat(chatSummary.id, chatSummary.title);
        };
        actionsDiv.appendChild(renameBtn);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-chat-btn";
        deleteBtn.innerHTML = '<i class="fas fa-trash" aria-hidden="true"></i>';
        deleteBtn.title = "Delete Chat";
        deleteBtn.setAttribute(
          "aria-label",
          `Delete chat ${chatSummary.title}`
        );
        deleteBtn.onclick = (e) => {
          e.stopPropagation(); // Prevent loading chat when clicking delete
          deleteChat(chatSummary.id, chatSummary.title);
        };
        actionsDiv.appendChild(deleteBtn);

        chatLink.appendChild(actionsDiv);

        chatLink.onclick = (e) => {
          e.preventDefault();
          loadChat(chatSummary.id);
        };
        chatHistoryList.appendChild(chatLink);
      });

      // Load the most recent chat if no current chat is active
      const isCurrentChatInList = chatSummaries.some(
        (summary) => summary.id === currentChatId
      );
      if (!currentChatId || !isCurrentChatInList) {
        currentChatId = chatSummaries[0].id; // Load the first chat by default
        await loadChat(currentChatId);
      } else {
        await loadChat(currentChatId); // Reload current chat to update active state
      }
    }
  } catch (error) {
    console.error("Error fetching chat history list:", error);
    addMessage(
      "Failed to load chat history. Please try refreshing.",
      "bot",
      null,
      new Date()
    );
  }
}

async function loadChat(id) {
  const chatbox = document.getElementById("chatbox");
  const newChatPlaceholder = document.getElementById("new-chat-placeholder");
  currentChatId = id;
  chatbox.innerHTML = ""; // Clear chatbox before loading new chat

  try {
    const response = await fetch(
      `${window.location.origin}/get_chat_messages/${id}`
    );
    const chatData = await response.json();

    if (chatData.length === 0) {
      // If loading an empty chat, show the placeholder
      if (newChatPlaceholder) {
        newChatPlaceholder.style.display = "flex";
      } else {
        const placeholderDiv = document.createElement("div");
        placeholderDiv.id = "new-chat-placeholder";
        placeholderDiv.className = "new-chat-placeholder";
        placeholderDiv.innerHTML = `
     <img src="/static/images/vexara-new1-removebg-preview.png" alt="V" style="width: 60px; height: 60px;     background-repeat: no-repeat;" />
          <span style="color = var(--text-color); font-size: 24px; font-weight: 600;">How can I help you?</span>
          
      `;
        chatbox.appendChild(placeholderDiv);
      }
    } else {
      // If there are messages, remove the placeholder if it exists
      if (newChatPlaceholder) {
        newChatPlaceholder.remove();
      }
      chatData.forEach((msg) => {
        const msgTimestamp = msg.timestamp
          ? new Date(msg.timestamp * 1000)
          : new Date();
        if (msg.type === "bot" && msg.image_urls && msg.image_urls.length > 0) {
          addMessage(msg.text, msg.type, msg.image_urls, msgTimestamp);
        } else if (msg.type === "user" && msg.image_url) {
          const imgElement = document.createElement("img");
          imgElement.src = msg.image_url;
          imgElement.classList.add("uploaded-image-preview");
          addMessage(msg.text, msg.type, imgElement, msgTimestamp);
        } else {
          addMessage(msg.text, msg.type, null, msgTimestamp);
        }
      });
    }

    // Update active state in chat history list
    document.querySelectorAll(".chat-link").forEach((link) => {
      link.classList.remove("active");
      link.setAttribute("aria-selected", "false");
    });
    const activeLink = document.querySelector(
      `.chat-link[data-chat-id="${currentChatId}"]`
    );
    if (activeLink) {
      activeLink.classList.add("active");
      activeLink.setAttribute("aria-selected", "true");
    }

    scrollToBottom();
  } catch (error) {
    console.error(`Error loading chat data for ${id}:`, error);
    addMessage(
      "Failed to load chat. It might have been deleted or corrupted.",
      "bot",
      null,
      new Date()
    );
  }
}

// NEW: Function to rename a chat
async function renameChat(chatId, currentTitle) {
  const newTitle = prompt(`Rename chat "${currentTitle}":`, currentTitle);
  if (newTitle && newTitle.trim() !== currentTitle) {
    try {
      const response = await fetch(
        `${window.location.origin}/rename_chat/${chatId}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ new_title: newTitle.trim() }),
        }
      );
      const result = await response.json();
      if (result.status === "success") {
        addMessage(
          `Chat "${currentTitle}" renamed to "${newTitle}".`,
          "bot",
          null,
          new Date()
        );
        await updateChatHistory(); // Refresh the sidebar
      } else {
        addMessage(
          `Failed to rename chat: ${result.error}`,
          "bot",
          null,
          new Date()
        );
      }
    } catch (error) {
      console.error("Error renaming chat:", error);
      const userErrorMessage = error.message.includes("Failed to fetch")
        ? "Could not connect to the server. Please check your network connection and ensure the server is running."
        : `An unexpected network error occurred: ${error.message}.`;
      addMessage(
        `Network error while renaming chat: ${userErrorMessage} Please try again.`,
        "bot",
        null,
        new Date()
      );
    }
  } else if (newTitle !== null && newTitle.trim() === "") {
    addMessage("Chat title cannot be empty.", "bot", null, new Date());
  }
}

// NEW: Function to delete a chat
async function deleteChat(chatId, chatTitle) {
  // Use the existing confirm modal for deletion
  const confirmModal = document.getElementById("confirmModal");
  const modalTitle = confirmModal.querySelector("h3");
  const modalParagraph = confirmModal.querySelector("p");
  const confirmBtn = document.getElementById("confirmClearBtn");
  const cancelBtn = confirmModal.querySelector(".modal-btn.cancel");

  modalTitle.textContent = `Delete Chat "${chatTitle}"?`;
  modalParagraph.textContent = `Are you sure you want to delete "${chatTitle}"? This action cannot be undone.`;
  confirmBtn.textContent = "Delete";
  confirmBtn.classList.remove("confirm"); // Remove 'confirm' class for general clear all
  confirmBtn.classList.add("modal-btn", "confirm"); // Re-add for delete specific styling

  // Temporarily remove previous listener and add new one for this specific action
  const oldConfirmListener = confirmBtn.onclick;
  confirmBtn.onclick = null; // Clear existing listener
  confirmBtn.addEventListener(
    "click",
    async function handler() {
      try {
        const response = await fetch(
          `${window.location.origin}/delete_chat/${chatId}`,
          {
            method: "POST",
          }
        );
        const result = await response.json();
        if (result.status === "success") {
          addMessage(`Chat "${chatTitle}" deleted.`, "bot", null, new Date());
          if (chatId === currentChatId) {
            // If the current chat was deleted, start a new one
            await startNewChat();
          } else {
            await updateChatHistory(); // Refresh the sidebar
          }
        } else {
          addMessage(
            `Failed to delete chat: ${result.error}`,
            "bot",
            null,
            new Date()
          );
        }
      } catch (error) {
        console.error("Error deleting chat:", error);
        const userErrorMessage = error.message.includes("Failed to fetch")
          ? "Could not connect to the server. Please check your network connection and ensure the server is running."
          : `An unexpected network error occurred: ${error.message}.`;
        addMessage(
          `Network error while deleting chat: ${userErrorMessage} Please try again.`,
          "bot",
          null,
          new Date()
        );
      } finally {
        hideModal();
        // Restore original confirm button listener if needed, or just keep it null for next use
        confirmBtn.onclick = oldConfirmListener;
        confirmBtn.removeEventListener("click", handler); // Remove this specific handler
        // Reset modal text to default for clear all chats
        modalTitle.textContent = `Clear All Chats?`;
        modalParagraph.textContent = `Are you sure you want to clear all chat history? This action cannot be undone.`;
        confirmBtn.textContent = "Clear All";
        confirmBtn.classList.remove("confirm");
        confirmBtn.classList.add("modal-btn", "confirm");
      }
    },
    { once: true }
  ); // Use { once: true } to automatically remove listener after first execution

  if (confirmModal) confirmModal.style.display = "flex";
}

// Initialize the app on DOMContentLoaded
document.addEventListener("DOMContentLoaded", async function () {
  // Apply dark mode if previously enabled
  if (localStorage.getItem("darkMode") === "enabled") {
    document.body.classList.add("dark-mode");
  }

  // Highlight all existing code blocks on load
  hljs.highlightAll();

  // Initialize Speech Recognition and Visualizer
  initializeSpeechRecognition();
  initializeVoiceVisualizer();

  // Initialize Speech Synthesis Voices
  if ("SpeechSynthesisUtterance" in window && "speechSynthesis" in window) {
    synth = window.speechSynthesis;
    synth.onvoiceschanged = setAIVoice; // Listen for voices to be loaded
    setAIVoice(); // Call immediately in case voices are already loaded
  } else {
    console.warn("Web Speech Synthesis API not supported.");
    addMessage(
      "Your browser does not support Web Speech Synthesis (AI voice output). Please use a compatible browser like Chrome or Edge.",
      "bot",
      null,
      new Date()
    );
  }

  // Element References (re-get if needed due to new elements)
  const sidebar = document.getElementById("sidebar");
  const showSidebarBtn = document.getElementById("showSidebarBtn");
  const sidebarToggleButton = document.getElementById("sidebarToggleButton"); // Changed from hideSidebarBtn
  const textInput = document.getElementById("text-input");
  const multiActionForm = document.getElementById("multi-action-form");
  const cameraOptions = document.querySelector(".camera-options");
  const takePhotoInput = document.getElementById("take-photo-input"); // NEW: Get the actual input
  const uploadPhotoInput = document.getElementById("upload-photo-input"); // NEW: Get the actual input
  const desktopFileInput = document.getElementById("desktop-file-input"); // NEW: Get the desktop file input
  const cancelCameraBtn = document.getElementById("cancel-camera");
  const clearImageBtn = document.getElementById("clear-image-btn"); // Get clear image button
  const clearAllChatsBtn = document.getElementById("clearAllChatsBtn");
  const confirmClearBtn = document.getElementById("confirmClearBtn");
  const modal = document.getElementById("confirmModal");
  const webSearchBtn = document.getElementById("web-search-btn"); // Get the new web search button
  const sendBtn = document.getElementById("send-btn"); // Reference to the send button
  const stopBtn = document.getElementById("stop-btn"); // Reference to the stop button
  const attachFileBtn = document.getElementById("attach-file-btn"); // NEW: Get the attach file button

  // New: Get radio buttons for model selection
  const modelGeneralRadio = document.getElementById("modelGeneral");
  const modelDeepThinkRadio = document.getElementById("modelDeepThink");
  // Removed fileInputLabel as it's now attachFileBtn

  // Event Listeners for UI interaction
  // Use sidebarToggleButton for collapsing/expanding the sidebar from inside
  if (sidebarToggleButton)
    sidebarToggleButton.addEventListener("click", toggleSidebar);
  // Use showSidebarBtn for showing the sidebar when it's fully hidden (mobile or desktop full screen)
  if (showSidebarBtn) showSidebarBtn.addEventListener("click", toggleSidebar);

  if (clearImageBtn) clearImageBtn.addEventListener("click", clearImagePreview); // Event listener for clear image button
  if (stopBtn) {
    // NEW: Add event listener for the stop button
    stopBtn.addEventListener("click", function () {
      if (abortController) {
        abortController.abort(); // Abort the ongoing fetch request
      }
      showSendButton(); // Immediately show send button
      document.getElementById("loader").style.display = "none"; // Hide loader
      stopSpeaking(); // Stop any ongoing speech
    });
  }

  // Responsive window resize handling
  window.addEventListener("resize", () => {
    // Adjust sidebar and main content behavior on resize
    const mainContent = document.querySelector(".main");
    if (window.innerWidth <= 768) {
      // On mobile, ensure sidebar is not 'collapsed' but rather 'visible' for slide-out
      if (sidebar.classList.contains("collapsed")) {
        sidebar.classList.remove("collapsed");
        mainContent.classList.remove("full-width");
      }
    } else {
      // On desktop, hide floating button if sidebar is open
      // Restore sidebar visibility based on previous state if on desktop
      if (!sidebarHidden) {
        // Only if not manually hidden
        sidebar.classList.remove("collapsed");
        mainContent.classList.remove("full-width");
      }
    }
    updateSidebarToggleButtonVisibility(); // Always call this on resize to ensure correct button state
  });

  // Auto-resize textarea based on content
  if (textInput) {
    textInput.addEventListener("input", () => {
      textInput.style.height = "auto"; // Reset height
      textInput.style.height = textInput.scrollHeight + "px"; // Set to scroll height
      // Toggle active class for send button based on text input
      if (textInput.value.trim().length > 0) {
        sendBtn.classList.add("active");
      } else {
        sendBtn.classList.remove("active");
      }
    });

    // NEW: Handle Enter key to send message
    textInput.addEventListener("keydown", function (e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault(); // Prevent new line
        multiActionForm.dispatchEvent(
          new Event("submit", { cancelable: true })
        ); // Trigger form submission
      }
    });
  }

  // Handle web search button click
  if (webSearchBtn) {
    webSearchBtn.addEventListener("click", async function () {
      const userText = textInput.value.trim();
      if (!userText) {
        console.error("Please enter a search query.");
        addMessage("Please enter a search query.", "bot", null, new Date());
        if (isVoiceTalkActive) speakText("Please enter a search query.");
        return;
      }
      // Add user message immediately
      addMessage(
        `Searching the web for: "${userText}"`,
        "user",
        null,
        new Date()
      );

      const loaderElement = document.getElementById("loader");
      loaderElement.style.display = "block"; // Show loader
      showStopButton(); // Show stop button
      stopSpeaking(); // Stop AI speech if any

      try {
        // Call askAI with the web_search flag set to true
        const modelChoice = document.querySelector(
          'input[name="modelChoice"]:checked'
        ).value;
        await askAI(userText, modelChoice, true); // Pass true for performSearch
      } catch (error) {
        console.error("Web search button error:", error);
        addMessage(
          "Sorry, an unexpected error occurred during web search. Please try again.",
          "bot",
          null,
          new Date()
        );
        if (isVoiceTalkActive)
          speakText(
            "Sorry, an unexpected error occurred during web search. Please try again."
          );
      } finally {
        loaderElement.style.display = "none"; // Hide loader
        textInput.value = "";
        textInput.style.height = "auto";
        textInput.focus();
        sendBtn.classList.remove("active"); // Remove active class after sending
        showSendButton(); // Show send button
      }
    });
  }

  // Camera options for mobile (take photo/upload from gallery)
  // Show camera options when the attach file button is clicked on mobile
  if (attachFileBtn) {
    // NEW: Use attachFileBtn
    attachFileBtn.addEventListener("click", function (event) {
      if (window.innerWidth <= 768) {
        event.preventDefault(); // Prevent default button behavior on mobile if we're showing a modal first
        cameraOptions.style.display = "block";
      } else {
        // On desktop, directly trigger the hidden file input
        desktopFileInput.click();
      }
    });
  }

  // NEW: Event listeners for the actual hidden file inputs (mobile)
  if (takePhotoInput) {
    takePhotoInput.addEventListener("change", function () {
      if (this.files.length > 0) {
        showImagePreview(this.files[0]);
      }
      cameraOptions.style.display = "none"; // Always hide options once file selection attempt is done
    });
  }

  if (uploadPhotoInput) {
    uploadPhotoInput.addEventListener("change", function () {
      if (this.files.length > 0) {
        showImagePreview(this.files[0]);
      }
      cameraOptions.style.display = "none"; // Always hide options once file selection attempt is done
    });
  }

  // NEW: Event listener for the desktop file input
  // This listener is still needed even if the input is clicked programmatically
  if (desktopFileInput) {
    desktopFileInput.addEventListener("change", function () {
      if (this.files.length > 0) {
        showImagePreview(this.files[0]);
      } else {
        clearImagePreview(); // Clear preview if user cancels desktop file picker
      }
    });
  }

  if (cancelCameraBtn) {
    cancelCameraBtn.addEventListener("click", function () {
      if (cameraOptions) cameraOptions.style.display = "none";
      clearImagePreview(); // Clear preview on cancel
    });
  }

  // Handle form submission based on input content and attached files
  if (multiActionForm) {
    multiActionForm.addEventListener("submit", async function (e) {
      e.preventDefault(); // Prevent default form submission
      const loaderElement = document.getElementById("loader");
      loaderElement.style.display = "block"; // Show loader for all submission types
      showStopButton(); // Show stop button on submit
      stopSpeaking(); // Stop AI speech if any

      const userText = textInput.value.trim();
      const modelChoice = document.querySelector(
        'input[name="modelChoice"]:checked'
      ).value; // Get selected model

      // Determine which file input (if any) has a file
      let selectedFile = null;
      if (takePhotoInput && takePhotoInput.files.length > 0) {
        selectedFile = takePhotoInput.files[0];
      } else if (uploadPhotoInput && uploadPhotoInput.files.length > 0) {
        selectedFile = uploadPhotoInput.files[0];
      } else if (desktopFileInput && desktopFileInput.files.length > 0) {
        // NEW: Check desktop input
        selectedFile = desktopFileInput.files[0];
      }
      const hasFile = selectedFile !== null;

      try {
        if (hasFile) {
          // Assume image upload if a file is present
          // Add user message with image preview immediately (optimistic update)
          const imgElementForChat = document.createElement("img");
          imgElementForChat.src = document.getElementById("image-preview").src;
          imgElementForChat.classList.add("uploaded-image-preview");
          const caption = userText
            ? `Image with caption: "${userText}"`
            : "Uploaded image";
          addMessage(caption, "user", imgElementForChat, new Date());

          // Now call the function that handles backend interaction
          await uploadImage(selectedFile, userText);
        } else {
          // Check for special commands
          const lowerCaseText = userText.toLowerCase();

          if (
            lowerCaseText.startsWith("generate image of") ||
            lowerCaseText.startsWith("create an image of") ||
            lowerCaseText.startsWith("picture of") ||
            lowerCaseText.startsWith("draw a") ||
            lowerCaseText.startsWith("make an image of")
          ) {
            addMessage(userText, "user", null, new Date()); // Add user text message immediately
            await generateImage(userText);
          } else if (lowerCaseText.startsWith("explain code")) {
            addMessage(userText, "user", null, new Date());
            await explainCode(userText.replace("explain code", "").trim());
          } else if (lowerCaseText.startsWith("grammar check")) {
            addMessage(userText, "user", null, new Date());
            await checkGrammarAndStyle(
              userText.replace("grammar check", "").trim()
            );
          } else if (
            lowerCaseText.startsWith("show html code") ||
            lowerCaseText.startsWith("show app html")
          ) {
            addMessage(
              "Requesting application HTML code...",
              "user",
              null,
              new Date()
            );
            const response = await fetch(
              `${window.location.origin}/get_app_html`
            );
            const htmlCode = await response.text();

            loaderElement.style.display = "none";
            showSendButton();

            addMessage(
              "Here is the current HTML code for the AI Assistant app:",
              "bot",
              null,
              new Date()
            );
            const codeMessage = document.createElement("div");
            codeMessage.className = `chat-message bot-message pulse`;
            const codeContentDiv = document.createElement("div");
            codeContentDiv.className = "message-content";
            codeContentDiv.innerHTML = marked.parse(
              `\`\`\`html\n${htmlCode}\n\`\`\``
            );
            codeMessage.appendChild(codeContentDiv);
            document.getElementById("chatbox").appendChild(codeMessage);
            scrollToBottom();
            hljs.highlightAll();

            if (isVoiceTalkActive)
              speakText(
                "Here is the current HTML code for the AI Assistant app."
              );
          } else if (!userText) {
            console.error("Please enter your input.");
            addMessage("Please enter your input.", "bot", null, new Date());
            if (isVoiceTalkActive) speakText("Please enter your input.");
            return;
          } else {
            // Default to Ask AI
            addMessage(userText, "user", null, new Date()); // Add user text message immediately
            await askAI(userText, modelChoice); // Pass modelChoice
          }
        }
      } catch (error) {
        console.error("Submission error:", error);
        addMessage(
          "Sorry, an unexpected error occurred. Please try again.",
          "bot",
          null,
          new Date()
        );
        if (isVoiceTalkActive)
          speakText("Sorry, an unexpected error occurred. Please try again.");
      } finally {
        loaderElement.style.display = "none";
        textInput.value = "";
        textInput.style.height = "auto";
        textInput.focus();
        clearImagePreview();
        sendBtn.classList.remove("active"); // Remove active class after sending
        showSendButton(); // Ensure send button is shown after any submission type
      }
    });
  }

  // Clear all chats confirmation and action
  if (clearAllChatsBtn) {
    clearAllChatsBtn.addEventListener("click", function () {
      // Reset modal to "Clear All Chats" default before showing
      const modalTitle = modal.querySelector("h3");
      const modalParagraph = modal.querySelector("p");
      const confirmBtn = document.getElementById("confirmClearBtn");

      modalTitle.textContent = `Clear All Chats?`;
      modalParagraph.textContent = `Are you sure you want to clear all chat history? This action cannot be undone.`;
      confirmBtn.textContent = "Clear All";
      confirmBtn.classList.remove("confirm"); // Ensure it has default confirm styling
      confirmBtn.classList.add("modal-btn", "confirm");

      // Remove any previous specific delete handler and add the general clear all handler
      confirmBtn.onclick = null; // Clear previous listeners
      confirmBtn.addEventListener(
        "click",
        async function handler() {
          try {
            const response = await fetch(`/clear_all_chats`, {
              method: "POST",
            });
            const result = await response.json();

            if (result.status === "success") {
              currentChatId = null; // Reset current chat ID
              document.getElementById("chatbox").innerHTML = ""; // Clear chat messages
              // Add the new chat placeholder back
              const chatbox = document.getElementById("chatbox");
              const placeholderDiv = document.createElement("div");
              placeholderDiv.id = "new-chat-placeholder";
              placeholderDiv.className = "new-chat-placeholder";
              placeholderDiv.innerHTML = `
                  <<img src="/static/images/vexara-new1-removebg-preview.png" alt="V" style="width: 90px; height: 90px; object-fit: contain;" />
          <span>How can I help you?</span>
                  
              `;
              chatbox.appendChild(placeholderDiv);

              addMessage(
                "All chat history cleared. How can I help you?",
                "bot",
                null,
                new Date()
              );
              if (isVoiceTalkActive)
                speakText("All chat history cleared. How can I help you.");
              await updateChatHistory(); // Refresh sidebar history
              if (modal) modal.style.display = "none";
            } else {
              console.error(
                "Failed to clear chats:",
                result.error || "Unknown error."
              );
              addMessage(
                "Failed to clear chats. Please try again.",
                "bot",
                null,
                new Date()
              );
              if (isVoiceTalkActive)
                speakText("Failed to clear chats. Please try again.");
            }
          } catch (error) {
            console.error("Network error while clearing chats:", error);
            addMessage(
              "Network error while clearing chats. Please try again.",
              "bot",
              null,
              new Date()
            );
            if (isVoiceTalkActive)
              speakText(
                "Network error while clearing chats. Please try again."
              );
          } finally {
            if (modal) modal.style.display = "none";
            confirmBtn.removeEventListener("click", handler); // Remove this specific handler
          }
        },
        { once: true }
      ); // Use { once: true } to automatically remove listener after first execution

      if (modal) modal.style.display = "flex";
    });
  }

  // Initial setup on page load
  await updateChatHistory(); // Load existing chat history or start new chat

  // Fetch user info (assuming a /user_info endpoint)
  fetch("/user_info")
    .then((response) => response.json())
    .then((data) => {
      const userInfoDiv = document.getElementById("user-info");
      const userEmailSpan = document.getElementById("user-email");
      if (data.user_email) {
        userEmailSpan.textContent = data.user_email;
        userInfoDiv.style.display = "flex"; // Show user info if email exists
      } else {
        userInfoDiv.style.display = "none";
      }
    })
    .catch((error) => console.error("Error fetching user info:", error));

  // Initial desktop sidebar state
  if (window.innerWidth > 768) {
    sidebar.classList.remove("collapsed");
    mainContentElement.classList.remove("full-width");
    sidebarHidden = false; // Sidebar starts open
  }
  updateSidebarToggleButtonVisibility(); // Set initial button visibility correctly
});

// Demo: Show animation during speech synthesis
// This function is for demonstration purposes and uses the new show/hide functions.
function speakWithAnimation(text) {
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.onstart = () => {
    showTalkingAnimation();
    // If you also want the full canvas visualizer for this demo:
    // startVoiceVisualizer(true);
  };
  utterance.onend = () => {
    hideTalkingAnimation();
    // If you were using the full canvas visualizer for this demo:
    // stopVoiceVisualizer();
  };
  utterance.onerror = () => {
    hideTalkingAnimation();
    // If you were using the full canvas visualizer for this demo:
    // stopVoiceVisualizer();
  };
  speechSynthesis.speak(utterance);
}

// let mod = document.getElementById("options-menu-btn");
// mod.addEventListener("click", function (e) {
//   e.preventDefault();
//   alert("btn clicked");
// });


// Handle + menu toggle
const plusMenuBtn = document.getElementById("plus-menu-btn");
const plusMenuContent = document.getElementById("plus-menu-content");

if (plusMenuBtn && plusMenuContent) {
  plusMenuBtn.addEventListener("click", () => {
    const isOpen = plusMenuContent.style.display === "block";
    plusMenuContent.style.display = isOpen ? "none" : "block";
    plusMenuBtn.setAttribute("aria-expanded", !isOpen);
  });

  // Close menu if clicking outside
  document.addEventListener("click", (e) => {
    if (!plusMenuBtn.contains(e.target) && !plusMenuContent.contains(e.target)) {
      plusMenuContent.style.display = "none";
      plusMenuBtn.setAttribute("aria-expanded", "false");
    }
  });
}

// Attach file button
const attachFileBtn = document.getElementById("attach-file-btn");
const desktopFileInput = document.getElementById("desktop-file-input");

if (attachFileBtn && desktopFileInput) {
  attachFileBtn.addEventListener("click", () => desktopFileInput.click());
  desktopFileInput.addEventListener("change", (e) => {
    if (e.target.files.length > 0) {
      console.log("Selected file:", e.target.files[0]);
      // 🔧 Your existing function for uploading/previewing files:
      // handleFileUpload(e.target.files[0]);
    }
  });
}

// Web Search button
const webSearchBtn = document.getElementById("web-search-btn");
if (webSearchBtn) {
  webSearchBtn.addEventListener("click", () => {
    console.log("Performing web search...");
    // 🔧 Replace with your existing web search function:
    // performWebSearch();
  });
}

// Deep Think radio
const deepThinkRadio = document.getElementById("modelDeepThink");
if (deepThinkRadio) {
  deepThinkRadio.addEventListener("change", () => {
    if (deepThinkRadio.checked) {
      console.log("Deep Think mode selected");
      // 🔧 Call your existing model switch logic:
      // setModel("deep_think");
    }
  });
}
// Function to add a thinking message to the chat
function addThinkingMessage() {
  const chatContainer = document.getElementById("chat-container");
  const thinkingMessage = document.createElement("div");
  thinkingMessage.className = "bot-message thinking-message";
  thinkingMessage.innerHTML = `
      <div class="thinking-dot"></div>
      <div class="thinking-dot"></div>
      <div class="thinking-dot"></div>
  `;
  chatContainer.appendChild(thinkingMessage);
  scrollToBottom();
  return thinkingMessage;
}
// Fix: Ensure the correct button state (Send visible, Stop hidden) on initial page load
document.addEventListener('DOMContentLoaded', () => {
  // Check if the function exists before calling it (for safety)
  if (typeof window.showSendButton === 'function') {
      window.showSendButton();
  }
});
// ==========================================================
// START: Code for Voice Talk/Submit Button Toggle and Fixes
// ==========================================================

// Function to manage the visibility of the Voice Talk and Send buttons
// This runs when the user types or when a response finishes.
function updateInputButtonState() {
    // Check if the required elements exist before proceeding
    const textInput = document.getElementById("text-input");
    const sendBtn = document.getElementById("send-btn");
    const voiceTalkBtn = document.getElementById("voice-talk-btn");
    const stopBtn = document.getElementById("stop-btn");

    if (!textInput || !sendBtn || !voiceTalkBtn || !stopBtn) return;

    // We assume the stop button is only visible when a response is generating.
    const isResponseGenerating = stopBtn.style.display !== "none";

    // If the AI is busy or Voice Talk is active, do not change the button state.
    if (isResponseGenerating || window.isVoiceTalkActive) {
        return;
    }

    // Check if the input field is empty (trimmed)
    if (textInput.value.trim().length === 0) {
        // Input is empty: Show Voice Talk, Hide Send
        voiceTalkBtn.style.display = "flex";
        sendBtn.style.display = "none";
    } else {
        // Input has text: Hide Voice Talk, Show Send
        voiceTalkBtn.style.display = "none";
        sendBtn.style.display = "flex";
    }
}

// Attach the new function to the input field so it updates dynamically as the user types
const textInput = document.getElementById("text-input");
if (textInput) {
    textInput.addEventListener("input", updateInputButtonState);
}


// IMPORTANT: You must MODIFY your existing showSendButton function, 
// DO NOT duplicate it. If you cannot modify it, ensure this code
// overwrites the old one if it's placed later in the file.
// This new version calls updateInputButtonState() to show the correct button.
window.showSendButton = function() {
    if (window.isVoiceTalkActive) return;
    document.getElementById("stop-btn").style.display = "none";
    
    // Determine whether to show Send or Voice Talk based on input content
    updateInputButtonState(); 
}


// Page Load Fix: Ensures the correct button state (Voice Talk visible if empty)
// is set when the page loads, resolving the initial "Stop Response" button issue.
document.addEventListener('DOMContentLoaded', () => {
    // Set the initial button state (shows Voice Talk if input is empty)
    if (typeof updateInputButtonState === 'function') {
        updateInputButtonState();
    }
});

// ==========================================================
// END: Code for Voice Talk/Submit Button Toggle and Fixes
// ==========================================================
// ==========================================================
// START: Code for Copy and Edit Functionality
// ==========================================================

// Global state to manage Read Aloud functionality
let currentSpeechUtterance = null;
let currentSpeechButton = null;

// Inline SVG for speaker (Play icon)
const speakerSVG = '<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>';

// Inline SVG for stop (Stop icon)
const stopSVG = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-stop-circle" viewBox="0 0 16 16"><path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14m0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16"/><path d="M5 6.5A1.5 1.5 0 0 1 6.5 5h3A1.5 1.5 0 0 1 11 6.5v3A1.5 1.5 0 0 1 9.5 11h-3A1.5 1.5 0 0 1 5 9.5z"/></svg>';

// Helper to reset the read aloud button visual state
function resetReadAloudButton(button) {
  button.innerHTML = speakerSVG;
  button.title = 'Read aloud';
  button.setAttribute('aria-label', 'Read message aloud');
  button.style.color = 'var(--text-color)';
}

// Function to stop all ongoing speech
function stopSpeaking() {
  if (window.speechSynthesis && speechSynthesis.speaking) {
    speechSynthesis.cancel();
  }
  // Reset the button visual state if speech was canceled
  if (currentSpeechButton) {
    resetReadAloudButton(currentSpeechButton);
    currentSpeechUtterance = null;
    currentSpeechButton = null;
  }
}

// Function to read the message content aloud
function readMessageAloud(button) {
  if (!('speechSynthesis' in window)) {
    console.error('Web Speech API is not supported in this browser.');
    // Simple visual feedback if not supported
    button.innerHTML = '<span style="color: red; font-size: 10px;">X</span>';
    setTimeout(() => {
        resetReadAloudButton(button);
    }, 2000);
    return;
  }

  const messageWrapper = button.closest('.chat-message');
  const contentElement = messageWrapper ? messageWrapper.querySelector('.message-content') : null;
  
  if (!contentElement) {
    console.error('Message content element not found.');
    return;
  }

  const textToSpeak = contentElement.innerText;

  // 1. Check if the current button is the one already speaking (toggle stop)
  if (currentSpeechButton === button) {
    stopSpeaking(); // This will also reset the button
    return;
  }

  // 2. Stop any existing speech from other buttons
  if (speechSynthesis.speaking) {
    stopSpeaking();
  }

  // 3. Start new speech
  const utterance = new SpeechSynthesisUtterance(textToSpeak);
  
  utterance.onstart = () => {
    // Set button state to active (stop icon)
    button.innerHTML = stopSVG;
    button.title = 'Stop reading';
    button.setAttribute('aria-label', 'Stop reading aloud');
    button.style.color = 'var(--text-color, #10b981)'; // Highlight active state
    currentSpeechButton = button;
    currentSpeechUtterance = utterance;
  };

  utterance.onend = () => {
    // Reset button state
    if (currentSpeechButton === button) {
      resetReadAloudButton(button);
      currentSpeechButton = null;
      currentSpeechUtterance = null;
    }
  };

  utterance.onerror = (event) => {
    console.error('Speech synthesis error:', event.error);
    if (currentSpeechButton === button) {
      resetReadAloudButton(button);
      currentSpeechButton = null;
      currentSpeechUtterance = null;
    }
  };

  // Speak the text
  speechSynthesis.speak(utterance);
}


// Function to copy text content to clipboard
function copyMessageContent(button) {
  const messageWrapper = button.closest('.chat-message');
  if (!messageWrapper) return;

  const contentElement = messageWrapper.querySelector('.message-content');
  if (!contentElement) return;

  const textToCopy = contentElement.innerText;

  // Use the modern Clipboard API if available
  if (navigator.clipboard) {
    navigator.clipboard.writeText(textToCopy).then(() => {
      // Success feedback
      const originalHTML = button.innerHTML;
      button.innerHTML = '<i class="fas fa-check"></i>';
      setTimeout(() => {
        button.innerHTML = originalHTML;
      }, 1000);
    }).catch(err => {
      console.error('Copy failed with Clipboard API:', err);
      // Fallback to old method if Clipboard API fails (or for older browsers)
      fallbackCopyTextToClipboard(textToCopy, button);
    });
  } else {
    // Fallback for older browsers
    fallbackCopyTextToClipboard(textToCopy, button);
  }
}

// Fallback function for copying text
function fallbackCopyTextToClipboard(textToCopy, button) {
    const tempTextArea = document.createElement('textarea');
    tempTextArea.value = textToCopy;
    tempTextArea.style.position = 'fixed';
    tempTextArea.style.left = '-9999px';
    document.body.appendChild(tempTextArea);
    tempTextArea.focus();
    tempTextArea.select();

    try {
        const successful = document.execCommand('copy');
        if (successful) {
            const originalHTML = button.innerHTML;
            button.innerHTML = '<i class="fas fa-check"></i>';
            setTimeout(() => {
                button.innerHTML = originalHTML;
            }, 1000);
        }
    } catch (err) {
        console.error('Copy failed with execCommand:', err);
    } finally {
        document.body.removeChild(tempTextArea);
    }
}
// Function to regenerate AI answer
async function askAI(instruction, modelChoice, performSearch = false, isRegenerate = false) {
  const textInput = document.getElementById("text-input");
  const loader = document.getElementById("loader");

  // Show loader BEFORE creating the streaming message
  loader.style.display = "block";
  showStopButton(); // Show stop button, hide send button
  stopSpeaking(); // Stop AI speech if any

  // Initialize AbortController for this request
  let abortController = new AbortController();
  const signal = abortController.signal;

  try {
    const formData = new FormData();
    
    // If it's a regenerate request, add cache-busting parameter
    const finalInstruction = isRegenerate ? 
      `${instruction} [regenerate:${Date.now()}]` : 
      instruction;
    
    formData.append("instruction", finalInstruction);
    formData.append("chat_id", currentChatId);
    formData.append("model_choice", modelChoice);
    formData.append("web_search", performSearch);

    const response = await fetch(`${window.location.origin}/ask`, {
      method: "POST",
      body: formData,
      signal: signal,
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Server error: ${response.status} ${response.statusText} - ${errorText}`
      );
    }

    // Hide loader once the actual streaming starts
    loader.style.display = "none";

    // Create the initial message container for streaming
    createStreamingBotMessage(new Date());

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let done = false;

    while (!done) {
      const { value, done: readerDone } = await reader.read();
      done = readerDone;
      const chunk = decoder.decode(value, { stream: true });
      if (chunk) {
        await appendToStreamingBotMessage(chunk);
      }
    }

    // Finalize the streaming message after stream finishes
    finalizeStreamingBotMessage();
  } catch (error) {
    loader.style.display = "none";
    if (error.name === "AbortError") {
      console.log("Fetch aborted by user.");
      if (currentBotMessageContentDiv) {
        currentBotMessageContentDiv.innerHTML += `<p>*(Response stopped by user)*</p>`;
      } else {
        addMessage(`Response stopped by user.`, "bot", null, new Date());
      }
    } else {
      console.error("Error asking AI:", error);
      if (currentBotMessageContentDiv) {
        currentBotMessageContentDiv.innerHTML += `<p>Error: ${error.message}</p>`;
      } else {
        addMessage(
          `Sorry, there was an error processing your request: ${error.message}. Please try again.`,
          "bot",
          null,
          new Date()
        );
      }
    }
    finalizeStreamingBotMessage();
  } finally {
    textInput.value = "";
    textInput.style.height = "auto";
    textInput.focus();
    showSendButton();
    // Reset abortController after potential use
    if (typeof abortController !== 'undefined') {
        // Assuming abortController is defined in a scope accessible by showStopButton/showSendButton context
        // This is a common pattern in the larger chat script, so we'll assume the original context handles this.
    }
  }
}
// Function to regenerate AI answer
function regenerateAnswer(button) {
  const messageWrapper = button.closest('.chat-message');
  if (!messageWrapper || !messageWrapper.classList.contains('bot-message')) return;

  // Find the previous user message
  const allMessages = Array.from(document.querySelectorAll('.chat-message'));
  const currentMessageIndex = allMessages.indexOf(messageWrapper);
  
  if (currentMessageIndex === -1 || currentMessageIndex === 0) return;
  
  // Look backwards for the most recent user message
  let userMessage = null;
  for (let i = currentMessageIndex - 1; i >= 0; i--) {
    if (allMessages[i].classList.contains('user-message')) {
      userMessage = allMessages[i];
      break;
    }
  }
  
  if (!userMessage) return;
  
  // Get the user's original text
  const userContent = userMessage.querySelector('.message-content');
  if (!userContent) return;
  
  const originalText = userContent.innerText.trim();
  
  if (!originalText) {
    console.error('No original user message text found for regeneration');
    return;
  }

  // Show loading state on the regenerate button
  const originalHTML = button.innerHTML;
  button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
  button.disabled = true;

  // Get the current model choice
  const modelChoiceInput = document.querySelector('input[name="modelChoice"]:checked');
  const modelChoice = modelChoiceInput ? modelChoiceInput.value : 'default';

  // Remove the current bot message that we're regenerating
  messageWrapper.remove();

  // Add the user message again to maintain context
  if (typeof addMessage === 'function') addMessage(originalText, "user", null, new Date());

  // Call askAI with regenerate flag set to true
  askAI(originalText, modelChoice, false, true)
    .finally(() => {
      // Restore the regenerate button (though it might be rebuilt if message actions are re-run)
      // This part might not execute if the new message is successfully generated before
      // this finally block runs, but it's kept for robustness.
      if (button.parentNode) {
          button.innerHTML = originalHTML;
          button.disabled = false;
      }
    });
}


// Function to edit user message
function editUserMessage(button) {
  const messageWrapper = button.closest('.chat-message');
  if (!messageWrapper || !messageWrapper.classList.contains('user-message')) return;

  const contentElement = messageWrapper.querySelector('.message-content');
  if (!contentElement) return;

  const currentText = contentElement.innerText.trim();
  const actionsContainer = messageWrapper.querySelector('.message-actions');

  if (actionsContainer) actionsContainer.style.display = 'none';
  contentElement.style.display = 'none';

  // --- Controls Container ---
  const editWrapper = document.createElement('div');
  editWrapper.className = 'message-edit-wrapper';
  editWrapper.style.cssText = `
    padding: 20px;
    border-radius: 12px; 
    background-color: var(--bg-color, #202020);
    margin: 10px 0;
    width: 100%;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    min-height: 120px;
    position: relative;
  `;

  // --- Text Area ---
  const editArea = document.createElement('textarea');
  editArea.style.cssText = `
    width: 100%; 
    height: auto; /* Auto height */
    min-height: 80px; /* Start taller */
    padding: 10px 0;
    border: none;
    border-radius: 0; 
    color: var(--text-color);
    background-color: var(--bg-color);
    box-sizing: border-box;
    font: inherit;
    resize: none;
    flex-grow: 1;
    outline: none; /* Removes blue outline */
    box-shadow: none; /* Ensures no blue glow */
    font-size: 16px; 
    line-height: 1.5;
    margin-bottom: 5px;
  `;
  editArea.value = currentText;
  // --- Controls (Cancel/Send) ---
  const controls = document.createElement('div');
  // Position the controls at the bottom right corner
  controls.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end; align-items: flex-end; padding-top: 10px;';
  
  // --- Cancel Button (Themed like the image) ---
  const cancelBtn = document.createElement('button');
  cancelBtn.textContent = 'Cancel';
  // *** STYLING MATCHING IMAGE ***
  cancelBtn.style.cssText = `
    padding: 8px 18px; 
    background: #363636; /* Dark background */
    color: white; 
    border: none; 
    border-radius: 18px; /* Pill shape */
    cursor: pointer;
    font-weight: 500;
    transition: background-color 0.2s;
  `;
  cancelBtn.onmouseover = () => cancelBtn.style.backgroundColor = '#4a4a4a';
  cancelBtn.onmouseout = () => cancelBtn.style.backgroundColor = '#363636';

  // --- Save & Resend Button (Themed like the image) ---
  const saveBtn = document.createElement('button');
  saveBtn.textContent = 'Send';
  // *** STYLING MATCHING IMAGE ***
  saveBtn.style.cssText = `
    padding: 8px 18px; 
    background: white; /* Light background */
    color: #202020; /* Dark text */
    border: none; 
    border-radius: 18px; 
    cursor: pointer;
    font-weight: 600;
    transition: background-color 0.2s;
  `;
  saveBtn.onmouseover = () => saveBtn.style.backgroundColor = '#f0f0f0';
  saveBtn.onmouseout = () => saveBtn.style.backgroundColor = 'white';


  controls.appendChild(cancelBtn);
  controls.appendChild(saveBtn);

  editWrapper.appendChild(editArea);
  editWrapper.appendChild(controls);

  contentElement.parentNode.insertBefore(editWrapper, contentElement.nextSibling);

  editArea.focus();

  cancelBtn.onclick = () => {
    contentElement.style.display = 'block';
    if (actionsContainer) actionsContainer.style.display = 'flex';
    editWrapper.remove();
  };

  saveBtn.onclick = () => {
    const newText = editArea.value.trim();
    if (newText && newText !== currentText) {
      if (typeof marked !== 'undefined') {
        contentElement.innerHTML = marked.parse(newText);
      } else {
        contentElement.innerText = newText;
      }
      
      contentElement.style.display = 'block';
      if (actionsContainer) actionsContainer.style.display = 'flex';
      editWrapper.remove();

      const modelChoiceInput = document.querySelector('input[name="modelChoice"]:checked');
      const modelChoice = modelChoiceInput ? modelChoiceInput.value : 'default';

      // Assuming these functions exist to handle chat logic
      if (typeof addMessage === 'function') addMessage(newText, "user", null, new Date());
      if (typeof askAI === 'function') askAI(newText, modelChoice);
    } else {
      cancelBtn.onclick();
    }
  };
}

// Function to add action buttons to messages
function addMessageActions(messageElement) {
  if (messageElement.querySelector('.message-actions')) return;

  const isBot = messageElement.classList.contains('bot-message');
  const isUser = messageElement.classList.contains('user-message');
  if (!isBot && !isUser) return;

  const actionsContainer = document.createElement('div');
  actionsContainer.className = 'message-actions';

  // Styling based on message type
  if (isUser) {
    actionsContainer.style.cssText = 'display: flex; gap: 5px; justify-content: flex-end; margin-top: 5px; margin-left: 10px;';
  } else {
    actionsContainer.style.cssText = 'display: flex; gap: 5px; justify-content: flex-start; margin-top: 5px; margin-right: 10px;';
  }

  // --- Shared Button Styling ---
  const buttonStyle = `
    background: none; 
    border: none; 
    cursor: pointer; 
    padding: 5px; 
    border-radius: 3px;
    color: var(--text-color); /* Use a light gray for inactive buttons */
    transition: color 0.2s;
  `;
  
  // Define active color (e.g., green for like, red for dislike)
  const likeActiveColor = 'var(--like-color, #10b981)'; // Example green color
  const dislikeActiveColor = 'var(--dislike-color, #ef4444)'; // Example red color

  // --- Regenerate Button (ONLY for bot messages) ---
  if (isBot) {
    const regenerateBtn = document.createElement('button');
    regenerateBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon"><path d="M3.502 16.6663V13.3333C3.502 12.9661 3.79977 12.6683 4.16704 12.6683H7.50004L7.63383 12.682C7.93691 12.7439 8.16508 13.0119 8.16508 13.3333C8.16508 13.6547 7.93691 13.9227 7.63383 13.9847L7.50004 13.9984H5.47465C6.58682 15.2249 8.21842 16.0013 10 16.0013C13.06 16.0012 15.5859 13.711 15.9551 10.7513L15.9854 10.6195C16.0845 10.3266 16.3785 10.1334 16.6973 10.1732C17.0617 10.2186 17.3198 10.551 17.2745 10.9154L17.2247 11.2523C16.6301 14.7051 13.6224 17.3313 10 17.3314C8.01103 17.3314 6.17188 16.5383 4.83208 15.2474V16.6663C4.83208 17.0335 4.53411 17.3311 4.16704 17.3314C3.79977 17.3314 3.502 17.0336 3.502 16.6663ZM4.04497 9.24935C3.99936 9.61353 3.66701 9.87178 3.30278 9.8265C2.93833 9.78105 2.67921 9.44876 2.72465 9.08431L4.04497 9.24935ZM10 2.66829C11.9939 2.66833 13.8372 3.46551 15.1778 4.76204V3.33333C15.1778 2.96616 15.4757 2.66844 15.8428 2.66829C16.2101 2.66829 16.5079 2.96606 16.5079 3.33333V6.66634C16.5079 7.03361 16.2101 7.33138 15.8428 7.33138H12.5098C12.1425 7.33138 11.8448 7.03361 11.8448 6.66634C11.8449 6.29922 12.1426 6.0013 12.5098 6.0013H14.5254C13.4133 4.77488 11.7816 3.99841 10 3.99837C6.93998 3.99837 4.41406 6.28947 4.04497 9.24935L3.38481 9.16634L2.72465 9.08431C3.17574 5.46702 6.26076 2.66829 10 2.66829Z"></path></svg>';
    regenerateBtn.style.cssText = buttonStyle;
    regenerateBtn.title = 'Regenerate response';
    regenerateBtn.setAttribute('aria-label', 'Regenerate AI response');
    regenerateBtn.onclick = () => regenerateAnswer(regenerateBtn);
    actionsContainer.appendChild(regenerateBtn);
  }

  // --- Copy Button ---
  const copyBtn = document.createElement('button');
  copyBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon"><path d="M12.668 10.667C12.668 9.95614 12.668 9.46258 12.6367 9.0791C12.6137 8.79732 12.5758 8.60761 12.5244 8.46387L12.4688 8.33399C12.3148 8.03193 12.0803 7.77885 11.793 7.60254L11.666 7.53125C11.508 7.45087 11.2963 7.39395 10.9209 7.36328C10.5374 7.33197 10.0439 7.33203 9.33301 7.33203H6.5C5.78896 7.33203 5.29563 7.33195 4.91211 7.36328C4.63016 7.38632 4.44065 7.42413 4.29688 7.47559L4.16699 7.53125C3.86488 7.68518 3.61186 7.9196 3.43555 8.20703L3.36524 8.33399C3.28478 8.49198 3.22795 8.70352 3.19727 9.0791C3.16595 9.46259 3.16504 9.95611 3.16504 10.667V13.5C3.16504 14.211 3.16593 14.7044 3.19727 15.0879C3.22797 15.4636 3.28473 15.675 3.36524 15.833L3.43555 15.959C3.61186 16.2466 3.86474 16.4807 4.16699 16.6348L4.29688 16.6914C4.44063 16.7428 4.63025 16.7797 4.91211 16.8027C5.29563 16.8341 5.78896 16.835 6.5 16.835H9.33301C10.0439 16.835 10.5374 16.8341 10.9209 16.8027C11.2965 16.772 11.508 16.7152 11.666 16.6348L11.793 16.5645C12.0804 16.3881 12.3148 16.1351 12.4688 15.833L12.5244 15.7031C12.5759 15.5594 12.6137 15.3698 12.6367 15.0879C12.6681 14.7044 12.668 14.211 12.668 13.5V10.667ZM13.998 12.665C14.4528 12.6634 14.8011 12.6602 15.0879 12.6367C15.4635 12.606 15.675 12.5492 15.833 12.4688L15.959 12.3975C16.2466 12.2211 16.4808 11.9682 16.6348 11.666L16.6914 11.5361C16.7428 11.3924 16.7797 11.2026 16.8027 10.9209C16.8341 10.5374 16.835 10.0439 16.835 9.33301V6.5C16.835 5.78896 16.8341 5.29563 16.8027 4.91211C16.7797 4.63025 16.7428 4.44063 16.6914 4.29688L16.6348 4.16699C16.4807 3.86474 16.2466 3.61186 15.959 3.43555L15.833 3.36524C15.675 3.28473 15.4636 3.22797 15.0879 3.19727C14.7044 3.16593 14.211 3.16504 13.5 3.16504H10.667C9.9561 3.16504 9.46259 3.16595 9.0791 3.19727C8.79739 3.22028 8.6076 3.2572 8.46387 3.30859L8.33399 3.36524C8.03176 3.51923 7.77886 3.75343 7.60254 4.04102L7.53125 4.16699C7.4508 4.32498 7.39397 4.53655 7.36328 4.91211C7.33985 5.19893 7.33562 5.54719 7.33399 6.00195H9.33301C10.022 6.00195 10.5791 6.00131 11.0293 6.03809C11.4873 6.07551 11.8937 6.15471 12.2705 6.34668L12.4883 6.46875C12.984 6.7728 13.3878 7.20854 13.6533 7.72949L13.7197 7.87207C13.8642 8.20859 13.9292 8.56974 13.9619 8.9707C13.9987 9.42092 13.998 9.97799 13.998 10.667V12.665ZM18.165 9.33301C18.165 10.022 18.1657 10.5791 18.1289 11.0293C18.0961 11.4302 18.0311 11.7914 17.8867 12.1279L17.8203 12.2705C17.5549 12.7914 17.1509 13.2272 16.6553 13.5313L16.4365 13.6533C16.0599 13.8452 15.6541 13.9245 15.1963 13.9619C14.8593 13.9895 14.4624 13.9935 13.9951 13.9951C13.9935 14.4624 13.9895 14.8593 13.9619 15.1963C13.9292 15.597 13.864 15.9576 13.7197 16.2939L13.6533 16.4365C13.3878 16.9576 12.9841 17.3941 12.4883 17.6982L12.2705 17.8203C11.8937 18.0123 11.4873 18.0915 11.0293 18.1289C10.5791 18.1657 10.022 18.165 9.33301 18.165H6.5C5.81091 18.165 5.25395 18.1657 4.80371 18.1289C4.40306 18.0962 4.04235 18.031 3.70606 17.8867L3.56348 17.8203C3.04244 17.5548 2.60585 17.151 2.30176 16.6553L2.17969 16.4365C1.98788 16.0599 1.90851 15.6541 1.87109 15.1963C1.83431 14.746 1.83496 14.1891 1.83496 13.5V10.667C1.83496 9.978 1.83432 9.42091 1.87109 8.9707C1.90851 8.5127 1.98772 8.10625 2.17969 7.72949L2.30176 7.51172C2.60586 7.0159 3.04236 6.6122 3.56348 6.34668L3.70606 6.28027C4.04237 6.136 4.40303 6.07083 4.80371 6.03809C5.14051 6.01057 5.53708 6.00551 6.00391 6.00391C6.00551 5.53708 6.01057 5.14051 6.03809 4.80371C6.0755 4.34588 6.15483 3.94012 6.34668 3.56348L6.46875 3.34473C6.77282 2.84912 7.20856 2.44514 7.72949 2.17969L7.87207 2.11328C8.20855 1.96886 8.56979 1.90385 8.9707 1.87109C9.42091 1.83432 9.978 1.83496 10.667 1.83496H13.5C14.1891 1.83496 14.746 1.83431 15.1963 1.87109C15.6541 1.90851 16.0599 1.98788 16.4365 2.17969L16.6553 2.30176C17.151 2.60585 17.5548 3.04244 17.8203 3.56351L17.8867 3.70608C18.031 4.04235 18.0962 4.40306 18.1289 4.80371C18.1657 5.25395 18.165 5.81091 18.165 6.5V9.33301Z"></path></svg>';
  copyBtn.style.cssText = buttonStyle;
  copyBtn.onclick = () => copyMessageContent(copyBtn);
  actionsContainer.appendChild(copyBtn);
  
  // --- Read Aloud Button (ONLY for bot messages, added after copy) ---


  // Like & Dislike buttons ONLY for bot messages
  if (isBot) {
    // --- Like Button ---
    const likeBtn = document.createElement('button');
    likeBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon"><path d="M10.9153 1.83987L11.2942 1.88772L11.4749 1.91507C13.2633 2.24201 14.4107 4.01717 13.9749 5.78225L13.9261 5.95901L13.3987 7.6719C13.7708 7.67575 14.0961 7.68389 14.3792 7.70608C14.8737 7.74486 15.3109 7.82759 15.7015 8.03323L15.8528 8.11819C16.5966 8.56353 17.1278 9.29625 17.3167 10.1475L17.347 10.3096C17.403 10.69 17.3647 11.0832 17.2835 11.5098C17.2375 11.7517 17.1735 12.0212 17.096 12.3233L16.8255 13.3321L16.4456 14.7276C16.2076 15.6001 16.0438 16.2356 15.7366 16.7305L15.595 16.9346C15.2989 17.318 14.9197 17.628 14.4866 17.8408L14.2982 17.9258C13.6885 18.1774 12.9785 18.1651 11.9446 18.1651H7.33331C6.64422 18.1651 6.08726 18.1657 5.63702 18.1289C5.23638 18.0962 4.87565 18.031 4.53936 17.8867L4.39679 17.8203C3.87576 17.5549 3.43916 17.151 3.13507 16.6553L3.013 16.4366C2.82119 16.0599 2.74182 15.6541 2.7044 15.1963C2.66762 14.7461 2.66827 14.1891 2.66827 13.5V11.667C2.66827 10.9349 2.66214 10.4375 2.77569 10.0137L2.83722 9.81253C3.17599 8.81768 3.99001 8.05084 5.01397 7.77639L5.17706 7.73928C5.56592 7.66435 6.02595 7.66799 6.66632 7.66799C6.9429 7.66799 7.19894 7.52038 7.33624 7.2803L10.2562 2.16995L10.3118 2.08792C10.4544 1.90739 10.6824 1.81092 10.9153 1.83987ZM7.33136 14.167C7.33136 14.9841 7.33714 15.2627 7.39386 15.4746L7.42999 15.5918C7.62644 16.1686 8.09802 16.6134 8.69171 16.7725L8.87042 16.8067C9.07652 16.8323 9.38687 16.835 10.0003 16.835H11.9446C13.099 16.835 13.4838 16.8228 13.7903 16.6963L13.8997 16.6465C14.1508 16.5231 14.3716 16.3444 14.5433 16.1221L14.6155 16.0166C14.7769 15.7552 14.8968 15.3517 15.1624 14.378L15.5433 12.9824L15.8079 11.9922C15.8804 11.7102 15.9368 11.4711 15.9769 11.2608C16.0364 10.948 16.0517 10.7375 16.0394 10.5791L16.0179 10.4356C15.9156 9.97497 15.641 9.57381 15.2542 9.31253L15.0814 9.20999C14.9253 9.12785 14.6982 9.06544 14.2747 9.03225C13.8477 8.99881 13.2923 8.99807 12.5003 8.99807C12.2893 8.99807 12.0905 8.89822 11.9651 8.72854C11.8398 8.55879 11.8025 8.33942 11.8646 8.13772L12.6556 5.56741L12.7054 5.36331C12.8941 4.35953 12.216 3.37956 11.1878 3.2178L8.49054 7.93948C8.23033 8.39484 7.81431 8.72848 7.33136 8.88967V14.167ZM3.99835 13.5C3.99835 14.2111 3.99924 14.7044 4.03058 15.0879C4.06128 15.4636 4.11804 15.675 4.19854 15.833L4.26886 15.959C4.44517 16.2466 4.69805 16.4808 5.0003 16.6348L5.13019 16.6905C5.27397 16.7419 5.46337 16.7797 5.74542 16.8028C5.97772 16.8217 6.25037 16.828 6.58722 16.8311C6.41249 16.585 6.27075 16.3136 6.1712 16.0215L6.10968 15.8194C5.99614 15.3956 6.00128 14.899 6.00128 14.167V9.00296C5.79386 9.0067 5.65011 9.01339 5.53741 9.02737L5.3587 9.06057C4.76502 9.21965 4.29247 9.66448 4.09601 10.2412L4.06085 10.3584C4.00404 10.5705 3.99835 10.8493 3.99835 11.667V13.5Z"></path></svg>';
    likeBtn.style.cssText = buttonStyle;

    // --- Dislike Button ---
    const dislikeBtn = document.createElement('button');
    dislikeBtn.innerHTML = '<svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor" xmlns="http://www.w3.org/2000/svg" class="icon"><path d="M12.6687 5.83304C12.6687 5.22006 12.6649 4.91019 12.6394 4.70413L12.6062 4.52542C12.4471 3.93179 12.0022 3.45922 11.4255 3.26272L11.3083 3.22757C11.0963 3.17075 10.8175 3.16507 9.99974 3.16507H8.0554C7.04558 3.16507 6.62456 3.17475 6.32982 3.26175L6.2097 3.30374C5.95005 3.41089 5.71908 3.57635 5.53392 3.78616L5.45677 3.87796C5.30475 4.0748 5.20336 4.33135 5.03392 4.91702L4.83763 5.6221L4.45677 7.01761C4.24829 7.78204 4.10326 8.31846 4.02318 8.73929C3.94374 9.15672 3.94298 9.39229 3.98119 9.56448L4.03587 9.75784C4.18618 10.1996 4.50043 10.5702 4.91771 10.7901L5.05052 10.8477C5.20009 10.9014 5.40751 10.9429 5.72533 10.9678C6.15231 11.0012 6.70771 11.002 7.49974 11.002C7.71076 11.002 7.90952 11.1018 8.0349 11.2715C8.14465 11.4201 8.18683 11.6067 8.15404 11.7862L8.13548 11.8623L7.34447 14.4326C7.01523 15.5033 7.71404 16.6081 8.81126 16.7813L11.5095 12.0606L11.5827 11.9405C11.8445 11.5461 12.2289 11.2561 12.6687 11.1094V5.83304ZM17.3318 8.33304C17.3318 8.97366 17.3364 9.43432 17.2615 9.82327L17.2234 9.98538C16.949 11.0094 16.1821 11.8233 15.1872 12.1621L14.9861 12.2237C14.5624 12.3372 14.0656 12.3321 13.3337 12.3321C13.0915 12.3321 12.8651 12.4453 12.7204 12.6348L12.6638 12.7198L9.74388 17.8301C9.61066 18.0631 9.35005 18.1935 9.08372 18.1602L8.70579 18.1123C6.75379 17.8682 5.49542 15.9213 6.07396 14.041L6.60033 12.3272C6.22861 12.3233 5.90377 12.3161 5.62083 12.294C5.18804 12.26 4.79914 12.1931 4.44701 12.0391L4.29857 11.9668C3.52688 11.5605 2.95919 10.8555 2.72533 10.0205L2.68333 9.85257C2.58769 9.42154 2.62379 8.97768 2.71654 8.49026C2.80865 8.00634 2.97082 7.41139 3.17357 6.668L3.55443 5.27249L3.74583 4.58011C3.9286 3.94171 4.10186 3.45682 4.40404 3.06546L4.53685 2.9053C4.85609 2.54372 5.25433 2.25896 5.70189 2.07425L5.93626 1.99222C6.49455 1.82612 7.15095 1.83499 8.0554 1.83499H12.6667C13.3558 1.83499 13.9128 1.83434 14.363 1.87112C14.8208 1.90854 15.2266 1.98789 15.6033 2.17972L15.821 2.30179C16.317 2.6059 16.7215 3.04226 16.987 3.56351L17.0535 3.70608C17.1977 4.04236 17.2629 4.40311 17.2956 4.80374C17.3324 5.25398 17.3318 5.81094 17.3318 6.50003V8.33304ZM13.9978 10.9961C14.3321 10.9901 14.5013 10.977 14.6413 10.9395L14.7585 10.9033C15.3353 10.7069 15.7801 10.2353 15.9392 9.64163L15.9724 9.46292C15.998 9.25682 16.0017 8.94657 16.0017 8.33304V6.50003C16.0017 5.78899 16.0008 5.29566 15.9695 4.91214C15.9464 4.6301 15.9086 4.44069 15.8572 4.2969L15.8015 4.16702C15.6475 3.86478 15.4133 3.6119 15.1257 3.43558L14.9997 3.36526C14.8418 3.28477 14.6302 3.228 14.2546 3.19729C14.0221 3.1783 13.7491 3.17109 13.4118 3.168C13.6267 3.47028 13.7914 3.81126 13.8904 4.18069L13.9275 4.34378C13.981 4.62163 13.9947 4.93582 13.9978 5.3262V10.9961Z"></path></svg>';
    dislikeBtn.style.cssText = buttonStyle;

    // --- Helper to get the path element inside the SVG ---
    const getPath = (btn) => btn.querySelector('svg path');

    // --- Toggle Logic Implementation ---
    likeBtn.onclick = () => {
      const path = getPath(likeBtn);
      const isCurrentlyActive = likeBtn.classList.contains('active');
      const inactiveColor = 'var(--text-color, #aaa)';

      if (isCurrentlyActive) {
        // Toggle off (remove like, show dislike)
        likeBtn.classList.remove('active');
        path.style.fill = inactiveColor;
        dislikeBtn.style.display = 'block';
      } else {
        // Toggle on (add like, fill icon, hide dislike)
        likeBtn.classList.add('active');
        path.style.fill = likeActiveColor; // Set to active color
        dislikeBtn.style.display = 'none';
        
        // Ensure dislike is inactive/hidden/unfilled
        dislikeBtn.classList.remove('active');
        getPath(dislikeBtn).style.fill = inactiveColor;
      }
    };

    dislikeBtn.onclick = () => {
      const path = getPath(dislikeBtn);
      const isCurrentlyActive = dislikeBtn.classList.contains('active');
      const inactiveColor = 'var(--text-color-inactive, #aaa)';

      if (isCurrentlyActive) {
        // Toggle off (remove dislike, show like)
        dislikeBtn.classList.remove('active');
        path.style.fill = inactiveColor;
        likeBtn.style.display = 'block';
      } else {
        // Toggle on (add dislike, fill icon, hide like)
        dislikeBtn.classList.add('active');
        path.style.fill = dislikeActiveColor; // Set to active color
        likeBtn.style.display = 'none';
        
        // Ensure like is inactive/hidden/unfilled
        likeBtn.classList.remove('active');
        getPath(likeBtn).style.fill = inactiveColor;
      }
    };

    actionsContainer.appendChild(likeBtn);
    actionsContainer.appendChild(dislikeBtn);
  }
    if (isBot) {
    const readAloudBtn = document.createElement('button');
    // Initial state setup using the reset helper
    resetReadAloudButton(readAloudBtn); 
    readAloudBtn.style.cssText = buttonStyle;
    readAloudBtn.onclick = () => readMessageAloud(readAloudBtn);
    actionsContainer.appendChild(readAloudBtn);
  }

  // --- Edit Button ---
  if (isUser) {
    const editBtn = document.createElement('button');
    editBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M9.94073 1.34948C10.7047 0.902375 11.6503 0.90248 12.4143 1.34948C12.706 1.52022 12.9687 1.79124 13.3104 2.1329C13.652 2.47454 13.9231 2.73727 14.0938 3.029C14.5408 3.79301 14.5409 4.73862 14.0938 5.50257C13.9231 5.79422 13.652 6.0571 13.3104 6.39867L6.65929 13.0498C6.28065 13.4284 6.00692 13.7108 5.6654 13.9097C5.32388 14.1085 4.94312 14.2074 4.42702 14.3498L3.24391 14.6762C2.77524 14.8054 2.34535 14.9263 2.00128 14.9685C1.65193 15.0112 1.17961 15.0014 0.810733 14.6326C0.44189 14.2637 0.432076 13.7914 0.474829 13.442C0.517004 13.098 0.63787 12.668 0.767151 12.1994L1.09349 11.0163C1.23585 10.5002 1.33478 10.1194 1.53356 9.77791C1.73246 9.43639 2.01487 9.16266 2.39352 8.78402L9.04463 2.1329C9.38622 1.79132 9.64908 1.52023 9.94073 1.34948ZM15.5427 14.8399H7.5522L8.96704 13.425H15.5427V14.8399ZM3.39379 9.78429C2.96497 10.2131 2.84241 10.3437 2.75706 10.4901C2.6718 10.6366 2.61858 10.8079 2.4573 11.3926L2.13096 12.5757C2.0018 13.0439 1.92191 13.3419 1.8886 13.5536C2.10038 13.5204 2.39869 13.4417 2.86761 13.3123L4.05072 12.986C4.63541 12.8247 4.80666 12.7715 4.9532 12.6862C5.09965 12.6009 5.23019 12.4783 5.65902 12.0495L10.721 6.9865L8.45574 4.72128L3.39379 9.78429ZM11.7 2.57085C11.3774 2.38205 10.9777 2.38205 10.6551 2.57085C10.5602 2.62653 10.4487 2.72937 10.0449 3.13317L9.45601 3.72101L11.7212 5.98623L12.3101 5.3984C12.7139 4.99464 12.8168 4.88314 12.8725 4.78825C13.0612 4.46567 13.0612 4.06592 12.8725 3.74333C12.8168 3.64834 12.7145 3.53758 12.3101 3.13317C11.9057 2.72869 11.795 2.62647 11.7 2.57085Z"></path></svg>';
    editBtn.style.cssText = buttonStyle;
    editBtn.onclick = () => editUserMessage(editBtn);
    actionsContainer.appendChild(editBtn);
  }

  const messageContent = messageElement.querySelector('.message-content');
  if (messageContent) {
    messageContent.parentNode.insertBefore(actionsContainer, messageContent.nextSibling); 
  } else {
    messageElement.appendChild(actionsContainer);
  }
}

// Observer to add buttons to new messages
const chatbox = document.getElementById('chatbox');
if (chatbox) {
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === 1 && node.classList.contains('chat-message')) {
          requestAnimationFrame(() => addMessageActions(node));
        }
      });
    });
  });

  observer.observe(chatbox, { childList: true });

  window.addEventListener('load', () => {
    const existingMessages = chatbox.querySelectorAll('.chat-message');
    existingMessages.forEach(msg => addMessageActions(msg));
  });
}


// ==========================================================
// END: Code for Copy, Edit, Regenerate, and Read Aloud Functionality
// ==========================================================
</script>

  </body>
</html>
